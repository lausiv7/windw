# WindWalker AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë” ì›Œí¬í”Œë¡œìš° êµ¬í˜„ ë¬¸ì„œ

## ğŸ“‹ êµ¬í˜„ ê°œìš”

ì´ ë¬¸ì„œëŠ” WindWalker ì¤‘ì•™ í—ˆë¸Œ ì•„í‚¤í…ì²˜ì— AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë”ë¥¼ í†µí•©í•˜ëŠ” 9ì£¼ê°„ì˜ êµ¬í˜„ ê³„íšì„ ì œì‹œí•©ë‹ˆë‹¤.

**í•µì‹¬ í†µí•© ì›ì¹™**: ê¸°ì¡´ MessageBridge ì¤‘ì‹¬ ì•„í‚¤í…ì²˜ë¥¼ í™•ì¥í•˜ì—¬ AI ì›Œí¬í”Œë¡œìš°ë¥¼ seamlessí•˜ê²Œ í†µí•©

12 WindWalker AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë” í†µí•© ì„¤ê³„ ë¬¸ì„œì— ê·¼ê±°í•˜ì—¬, 
í†µí•© ì „ì˜  11 AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë” ì›Œí¬í”Œë¡œìš° ì„¤ê³„ ë¬¸ì„œëŒ€ë¡œ ì‘ì„±ëœ,
13 AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë” ì›Œí¬í”Œë¡œìš° êµ¬í˜„ ë¬¸ì„œ

Phase 1: í…œí”Œë¦¿ ì‹œìŠ¤í…œ (2ì£¼)
* [ ] í…œí”Œë¦¿ ë©”íƒ€ë°ì´í„° êµ¬ì¡° ì„¤ê³„
* [ ] ê¸°ë³¸ í…œí”Œë¦¿ 5ê°œ ì œì‘ (ë¸”ë¡œê·¸, ì‡¼í•‘ëª°, í¬íŠ¸í´ë¦¬ì˜¤, ì¹´í˜, íšŒì‚¬ì†Œê°œ)
* [ ] í…œí”Œë¦¿ ì¶”ì²œ ì—”ì§„ êµ¬í˜„
* [ ] ì˜ë„ íŒŒì•… AI í”„ë¡¬í”„íŠ¸ ê°œë°œ
Phase 2: ëŒ€í™”í˜• ì»¤ìŠ¤í„°ë§ˆì´ì§• (3ì£¼)
* [ ] ConversationalCustomizer êµ¬í˜„
* [ ] ì œì•½ ì¡°ê±´ ì‹œìŠ¤í…œ êµ¬ì¶•
* [ ] ë³€ê²½ì‚¬í•­ ê²€ì¦ ë¡œì§
* [ ] ëŒ€ì•ˆ ìƒì„± ì•Œê³ ë¦¬ì¦˜
Phase 3: ë¹„êµ ë° ì„ íƒ UI (2ì£¼)
* [ ] ìˆ˜ì • ì „/í›„ ë¹„êµ WebView
* [ ] ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ìƒì„±
* [ ] ì„ íƒì§€ UI/UX êµ¬í˜„
* [ ] ì‚¬ìš©ì í”¼ë“œë°± ì‹œìŠ¤í…œ
Phase 4: ìµœì í™” ë° ê³ ë„í™” (2ì£¼)
* [ ] ì„±ëŠ¥ ìµœì í™” (ë¹Œë“œ ìºì‹±, ë¯¸ë¦¬ë³´ê¸° ìµœì í™”)
* [ ] ì‚¬ìš©ì í•™ìŠµ ê¸°ë°˜ ì¶”ì²œ ê°œì„ 
* [ ] A/B í…ŒìŠ¤íŠ¸ ê¸°ëŠ¥
* [ ] ë¶„ì„ ë° ê°œì„ ì‚¬í•­ ë„ì¶œ




## ğŸš€ Phase 1: í…œí”Œë¦¿ ì‹œìŠ¤í…œ (2ì£¼)

### Week 1: í…œí”Œë¦¿ ë©”íƒ€ë°ì´í„° êµ¬ì¡° ë° ê¸°ë³¸ í…œí”Œë¦¿ ì œì‘

#### ğŸ¯ ì£¼ìš” ì‘ì—…
- [ ] **í…œí”Œë¦¿ ë©”íƒ€ë°ì´í„° êµ¬ì¡° ì„¤ê³„**
- [ ] **ê¸°ë³¸ í…œí”Œë¦¿ 5ê°œ ì œì‘**
- [ ] **TemplateManager ì»´í¬ë„ŒíŠ¸ êµ¬í˜„**

#### ğŸ“Š í…œí”Œë¦¿ ë©”íƒ€ë°ì´í„° êµ¬ì¡°
```typescript
interface TemplateMetadata {
  id: string
  name: string
  category: 'blog' | 'ecommerce' | 'portfolio' | 'restaurant' | 'corporate'
  description: string
  tags: string[]
  difficulty: 'beginner' | 'intermediate' | 'advanced'
  
  // AI ì›Œí¬í”Œë¡œìš°ìš© ë©”íƒ€ë°ì´í„°
  customizationPoints: CustomizationPoint[]
  constraints: DesignConstraints
  recommendedFor: UserProfile[]
  
  // ê¸°ìˆ ì  ë©”íƒ€ë°ì´í„°
  components: ComponentInfo[]
  dependencies: string[]
  buildConfig: BuildConfiguration
  
  // ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íƒ€ë°ì´í„°
  industry: string[]
  targetAudience: string[]
  keyFeatures: string[]
}

interface CustomizationPoint {
  id: string
  name: string
  type: 'color' | 'layout' | 'content' | 'component' | 'style'
  description: string
  constraints: PointConstraints
  aiPromptHints: string[]
}
```

#### ğŸ—ï¸ ê¸°ë³¸ í…œí”Œë¦¿ 5ê°œ ìƒì„¸ ìŠ¤í™

##### 1. ë¸”ë¡œê·¸ í…œí”Œë¦¿ ("Modern Blog")
```typescript
const blogTemplate: TemplateMetadata = {
  id: 'blog-modern-001',
  name: 'Modern Blog',
  category: 'blog',
  description: 'ê¹”ë”í•˜ê³  ì½ê¸° ì‰¬ìš´ í˜„ëŒ€ì  ë¸”ë¡œê·¸ í…œí”Œë¦¿',
  tags: ['responsive', 'seo-friendly', 'dark-mode'],
  
  customizationPoints: [
    {
      id: 'header-style',
      name: 'í—¤ë” ìŠ¤íƒ€ì¼',
      type: 'layout',
      description: 'í—¤ë” ë ˆì´ì•„ì›ƒê³¼ ë„¤ë¹„ê²Œì´ì…˜ ìŠ¤íƒ€ì¼',
      constraints: { 
        allowedLayouts: ['centered', 'left-aligned', 'split'],
        maxMenuItems: 7 
      },
      aiPromptHints: ['ë„¤ë¹„ê²Œì´ì…˜', 'ë¡œê³  ìœ„ì¹˜', 'ë©”ë‰´ ìŠ¤íƒ€ì¼']
    },
    {
      id: 'color-scheme',
      name: 'ì»¬ëŸ¬ ìŠ¤í‚´',
      type: 'color',
      description: 'ì „ì²´ ì‚¬ì´íŠ¸ ìƒ‰ìƒ í…Œë§ˆ',
      constraints: {
        primaryColors: 'unlimited',
        contrastRatio: 'WCAG-AA'
      },
      aiPromptHints: ['ë¸Œëœë“œ ì»¬ëŸ¬', 'ë‹¤í¬ëª¨ë“œ', 'accent ì»¬ëŸ¬']
    }
  ],
  
  components: [
    { name: 'Header', customizable: true, required: true },
    { name: 'PostGrid', customizable: true, required: true },
    { name: 'Sidebar', customizable: true, required: false },
    { name: 'Footer', customizable: true, required: true }
  ]
}
```

##### 2. ì‡¼í•‘ëª° í…œí”Œë¦¿ ("E-commerce Pro")
```typescript
const ecommerceTemplate: TemplateMetadata = {
  id: 'ecommerce-pro-001',
  name: 'E-commerce Pro',
  category: 'ecommerce',
  description: 'ì „ë¬¸ì ì¸ ì˜¨ë¼ì¸ ì‡¼í•‘ëª° í…œí”Œë¦¿',
  tags: ['cart', 'payment', 'product-showcase'],
  
  customizationPoints: [
    {
      id: 'product-layout',
      name: 'ìƒí’ˆ ì§„ì—´ ë°©ì‹',
      type: 'layout',
      description: 'ìƒí’ˆì„ í‘œì‹œí•˜ëŠ” ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ',
      constraints: {
        gridOptions: [2, 3, 4, 6],
        cardStyles: ['minimal', 'detailed', 'hover-effect']
      },
      aiPromptHints: ['ìƒí’ˆ ê·¸ë¦¬ë“œ', 'ì¹´ë“œ ë””ìì¸', 'í˜¸ë²„ íš¨ê³¼']
    }
  ]
}
```

##### 3. í¬íŠ¸í´ë¦¬ì˜¤ í…œí”Œë¦¿ ("Creative Portfolio")
```typescript
const portfolioTemplate: TemplateMetadata = {
  id: 'portfolio-creative-001',
  name: 'Creative Portfolio',
  category: 'portfolio',
  description: 'ì°½ì‘ìë¥¼ ìœ„í•œ í¬íŠ¸í´ë¦¬ì˜¤ í…œí”Œë¦¿',
  tags: ['gallery', 'animation', 'showcase']
}
```

##### 4. ì¹´í˜ í…œí”Œë¦¿ ("Cozy Cafe")
```typescript
const cafeTemplate: TemplateMetadata = {
  id: 'cafe-cozy-001',
  name: 'Cozy Cafe',
  category: 'restaurant',
  description: 'ë”°ëœ»í•œ ë¶„ìœ„ê¸°ì˜ ì¹´í˜ ì›¹ì‚¬ì´íŠ¸',
  tags: ['menu', 'location', 'warm-design']
}
```

##### 5. íšŒì‚¬ì†Œê°œ í…œí”Œë¦¿ ("Corporate Clean")
```typescript
const corporateTemplate: TemplateMetadata = {
  id: 'corporate-clean-001',
  name: 'Corporate Clean',
  category: 'corporate',
  description: 'ì‹ ë¢°ê° ìˆëŠ” ê¸°ì—… ì†Œê°œ í˜ì´ì§€',
  tags: ['professional', 'team', 'services']
}
```

#### ğŸ”§ TemplateManager êµ¬í˜„
```typescript
class TemplateManager {
  private templates: Map<string, TemplateMetadata> = new Map()
  private templateFiles: Map<string, TemplateFiles> = new Map()

  constructor(
    private fileManager: FileManager,
    private aiContextManager: AIContextManager
  ) {}

  async loadTemplate(templateId: string): Promise<TemplateFiles> {
    const cached = this.templateFiles.get(templateId)
    if (cached) return cached

    const template = await this.fileManager.readTemplateFiles(templateId)
    this.templateFiles.set(templateId, template)
    return template
  }

  async recommendTemplates(userInput: string): Promise<TemplateRecommendation[]> {
    const intent = await this.aiContextManager.analyzeIntent(userInput)
    const matching = this.findMatchingTemplates(intent)
    
    return matching.map(template => ({
      template,
      confidence: this.calculateConfidence(intent, template),
      reasons: this.generateReasons(intent, template)
    }))
  }

  private findMatchingTemplates(intent: UserIntent): TemplateMetadata[] {
    return Array.from(this.templates.values())
      .filter(template => this.matchesIntent(template, intent))
      .sort((a, b) => this.calculateRelevance(b, intent) - this.calculateRelevance(a, intent))
      .slice(0, 3)
  }
}
```

### Week 2: í…œí”Œë¦¿ ì¶”ì²œ ì—”ì§„ ë° ì˜ë„ íŒŒì•… AI

#### ğŸ¯ ì£¼ìš” ì‘ì—…
- [ ] **ì˜ë„ íŒŒì•… AI í”„ë¡¬í”„íŠ¸ ê°œë°œ**
- [ ] **í…œí”Œë¦¿ ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„**
- [ ] **MessageBridge AI ë¼ìš°í„° í†µí•©**

#### ğŸ§  ì˜ë„ íŒŒì•… AI í”„ë¡¬í”„íŠ¸ ì‹œìŠ¤í…œ
```typescript
class IntentAnalyzer {
  private intentPrompts = {
    classification: `
ì‚¬ìš©ì ì…ë ¥ì„ ë¶„ì„í•˜ì—¬ ì›¹ì‚¬ì´íŠ¸ ìœ í˜•ì„ ë¶„ë¥˜í•´ì£¼ì„¸ìš”.

ì…ë ¥: "${userInput}"

ë¶„ë¥˜ ê¸°ì¤€:
1. ë¹„ì¦ˆë‹ˆìŠ¤ ìœ í˜•: [blog, ecommerce, portfolio, restaurant, corporate, landing, community]
2. ì£¼ìš” ëª©ì : [showcase, sales, information, engagement, branding]
3. íƒ€ê²Ÿ ëŒ€ìƒ: [personal, business, organization, creative, technical]
4. í•„ìˆ˜ ê¸°ëŠ¥: ì‚¬ìš©ìê°€ ì–¸ê¸‰í•œ êµ¬ì²´ì  ê¸°ëŠ¥ë“¤
5. ë””ìì¸ ì„ í˜¸: ì–¸ê¸‰ëœ ìŠ¤íƒ€ì¼, ìƒ‰ìƒ, ë ˆì´ì•„ì›ƒ ì„ í˜¸ë„

JSON í˜•íƒœë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "businessType": "...",
  "purpose": "...",
  "target": "...",
  "requiredFeatures": [...],
  "designPreferences": {...},
  "confidence": 0.85
}
    `,
    
    refinement: `
ì‚¬ìš©ìì˜ ìˆ˜ì • ìš”ì²­ì„ ë¶„ì„í•´ì£¼ì„¸ìš”.

í˜„ì¬ í…œí”Œë¦¿: ${currentTemplate}
ì‚¬ìš©ì ìš”ì²­: "${userInput}"

ë¶„ì„ ê²°ê³¼:
1. ìˆ˜ì • ëŒ€ìƒ: [header, content, layout, colors, components, functionality]
2. ìˆ˜ì • ìœ í˜•: [style, content, structure, behavior]
3. êµ¬ì²´ì„± ìˆ˜ì¤€: [vague, specific, detailed]
4. ì‹¤í˜„ ê°€ëŠ¥ì„±: [easy, medium, complex, impossible]

ì œì•½ ì¡°ê±´ ë‚´ì—ì„œ ê°€ëŠ¥í•œ ìˆ˜ì •ì‚¬í•­ê³¼ ëŒ€ì•ˆì„ ì œì‹œí•´ì£¼ì„¸ìš”.
    `
  }

  async analyzeUserIntent(input: string, context?: ConversationContext): Promise<UserIntent> {
    const prompt = this.buildContextualPrompt(input, context)
    const response = await this.callLLM(prompt)
    return this.parseIntentResponse(response)
  }
}
```

#### ğŸ¯ í…œí”Œë¦¿ ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜
```typescript
class TemplateRecommendationEngine {
  calculateTemplateScore(template: TemplateMetadata, intent: UserIntent): number {
    let score = 0
    
    // ë¹„ì¦ˆë‹ˆìŠ¤ íƒ€ì… ë§¤ì¹­ (40%)
    if (template.category === intent.businessType) {
      score += 0.4
    }
    
    // ê¸°ëŠ¥ ë§¤ì¹­ (30%)
    const featureMatch = this.calculateFeatureMatch(template.keyFeatures, intent.requiredFeatures)
    score += featureMatch * 0.3
    
    // íƒ€ê²Ÿ ëŒ€ìƒ ë§¤ì¹­ (20%)
    const audienceMatch = this.calculateAudienceMatch(template.targetAudience, intent.target)
    score += audienceMatch * 0.2
    
    // ë””ìì¸ ì„ í˜¸ë„ ë§¤ì¹­ (10%)
    const styleMatch = this.calculateStyleMatch(template.tags, intent.designPreferences)
    score += styleMatch * 0.1
    
    return Math.min(score, 1.0)
  }

  generateRecommendationReasons(template: TemplateMetadata, intent: UserIntent): string[] {
    const reasons = []
    
    if (template.category === intent.businessType) {
      reasons.push(`${intent.businessType} ì¹´í…Œê³ ë¦¬ì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤`)
    }
    
    const matchingFeatures = template.keyFeatures.filter(feature => 
      intent.requiredFeatures.some(required => 
        this.isFeatureMatch(feature, required)
      )
    )
    
    if (matchingFeatures.length > 0) {
      reasons.push(`ìš”ì²­í•˜ì‹  ${matchingFeatures.join(', ')} ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤`)
    }
    
    return reasons
  }
}
```

#### ğŸ”— MessageBridge í†µí•©
```typescript
// ê¸°ì¡´ MessageBridge í™•ì¥
class EnhancedMessageBridge extends MessageBridge {
  private templateManager: TemplateManager
  private intentAnalyzer: IntentAnalyzer
  
  async handleAIWorkflowMessage(message: AIWorkflowMessage): Promise<void> {
    switch (message.workflowType) {
      case 'template:search':
        await this.handleTemplateSearch(message)
        break
      case 'template:apply':
        await this.handleTemplateApplication(message)
        break
      case 'intent:analyze':
        await this.handleIntentAnalysis(message)
        break
    }
  }

  private async handleTemplateSearch(message: TemplateSearchMessage): Promise<void> {
    const recommendations = await this.templateManager.recommendTemplates(message.query)
    
    this.postToWebView('ai-chat', {
      type: 'template:recommendations',
      data: {
        query: message.query,
        templates: recommendations,
        timestamp: Date.now()
      }
    })
  }
}
```

## ğŸ¨ Phase 2: ëŒ€í™”í˜• ì»¤ìŠ¤í„°ë§ˆì´ì§• (3ì£¼)

### Week 3-4: ConversationalCustomizer êµ¬í˜„

#### ğŸ¯ ì£¼ìš” ì‘ì—…
- [ ] **ConversationalCustomizer í•µì‹¬ ì—”ì§„ ê°œë°œ**
- [ ] **ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ëŒ€í™” ê´€ë¦¬**
- [ ] **ë‹¨ê³„ë³„ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì›Œí¬í”Œë¡œìš°**

#### ğŸ¤– ConversationalCustomizer êµ¬í˜„
```typescript
class ConversationalCustomizer {
  private conversationHistory: ConversationStep[] = []
  private currentProject: ProjectState
  private constraintEngine: ConstraintEngine

  constructor(
    private codeGenerationService: CodeGenerationService,
    private buildManager: BuildManager,
    private aiContextManager: AIContextManager
  ) {}

  async processCustomizationRequest(
    request: CustomizationRequest,
    context: ConversationContext
  ): Promise<CustomizationResponse> {
    
    // 1. ìš”ì²­ ë¶„ì„ ë° ê²€ì¦
    const analysis = await this.analyzeRequest(request, context)
    
    // 2. ì œì•½ ì¡°ê±´ í™•ì¸
    const constraints = await this.constraintEngine.validateRequest(analysis, this.currentProject)
    
    if (!constraints.isValid) {
      return this.generateConstraintResponse(constraints)
    }
    
    // 3. ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ ìƒì„±
    const options = await this.generateCustomizationOptions(analysis, constraints)
    
    // 4. ë¯¸ë¦¬ë³´ê¸° ìƒì„±
    const previews = await this.generatePreviews(options)
    
    // 5. ì‘ë‹µ êµ¬ì„±
    return {
      type: 'customization:options',
      options: options.map((option, index) => ({
        id: `option-${Date.now()}-${index}`,
        description: option.description,
        changes: option.changes,
        previewUrl: previews[index],
        intensity: option.intensity,
        reasoning: option.reasoning
      })),
      context: this.updateContext(context, analysis)
    }
  }

  private async generateCustomizationOptions(
    analysis: RequestAnalysis,
    constraints: ValidationResult
  ): Promise<CustomizationOption[]> {
    
    const prompts = this.buildCustomizationPrompts(analysis, constraints)
    
    // 3ê°€ì§€ ê°•ë„ë³„ ì˜µì…˜ ìƒì„±
    const options = await Promise.all([
      this.generateOption('conservative', prompts.conservative),
      this.generateOption('balanced', prompts.balanced),
      this.generateOption('bold', prompts.bold)
    ])
    
    return options
  }

  private buildCustomizationPrompts(
    analysis: RequestAnalysis,
    constraints: ValidationResult
  ): CustomizationPrompts {
    
    const baseContext = `
í˜„ì¬ í…œí”Œë¦¿: ${this.currentProject.templateBase.name}
ìˆ˜ì • ëŒ€ìƒ: ${analysis.target}
ì‚¬ìš©ì ìš”ì²­: ${analysis.userRequest}
ê¸°ìˆ ì  ì œì•½: ${JSON.stringify(constraints.technicalLimits)}
ë””ìì¸ ì œì•½: ${JSON.stringify(constraints.designLimits)}
`

    return {
      conservative: `
${baseContext}

ë³´ìˆ˜ì  ì ‘ê·¼ë²•ìœ¼ë¡œ ìˆ˜ì •í•´ì£¼ì„¸ìš”:
- ê¸°ì¡´ ë””ìì¸ ì–¸ì–´ ìœ ì§€
- ìµœì†Œí•œì˜ ë³€ê²½ìœ¼ë¡œ ìš”êµ¬ì‚¬í•­ ì¶©ì¡±
- í˜¸í™˜ì„±ê³¼ ì•ˆì •ì„± ìš°ì„ 
- ê¸°ì¡´ ì‚¬ìš©ì ê²½í—˜ íŒ¨í„´ ìœ ì§€
      `,
      
      balanced: `
${baseContext}

ê· í˜•ì  ì ‘ê·¼ë²•ìœ¼ë¡œ ìˆ˜ì •í•´ì£¼ì„¸ìš”:
- ì ì ˆí•œ ìˆ˜ì¤€ì˜ í˜ì‹ ê³¼ ì•ˆì •ì„±
- ì‚¬ìš©ì ìš”êµ¬ì— ë§ëŠ” ì ê·¹ì  ê°œì„ 
- í˜„ëŒ€ì  ë””ìì¸ íŠ¸ë Œë“œ ë°˜ì˜
- ì‚¬ìš©ì„±ê³¼ ë¯¸ì  ê°€ì¹˜ì˜ ê· í˜•
      `,
      
      bold: `
${baseContext}

ëŒ€ë‹´í•œ ì ‘ê·¼ë²•ìœ¼ë¡œ ìˆ˜ì •í•´ì£¼ì„¸ìš”:
- ì°½ì˜ì ì´ê³  í˜ì‹ ì ì¸ ë””ìì¸
- ìµœì‹  ì›¹ ê¸°ìˆ ê³¼ íŠ¸ë œë“œ ì ê·¹ í™œìš©
- ì‹œê°ì  ì„íŒ©íŠ¸ ê·¹ëŒ€í™”
- ë…íŠ¹í•˜ê³  ê¸°ì–µì— ë‚¨ëŠ” ê²½í—˜ ì œê³µ
      `
    }
  }
}
```

#### ğŸ”— ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ ì‹œìŠ¤í…œ
```typescript
class ConversationContextManager {
  private contexts: Map<string, ConversationContext> = new Map()
  
  updateContext(
    sessionId: string, 
    step: ConversationStep
  ): ConversationContext {
    
    const context = this.contexts.get(sessionId) || this.createNewContext(sessionId)
    
    // ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
    context.steps.push(step)
    context.currentState = this.deriveStateFromSteps(context.steps)
    context.userPreferences = this.updatePreferences(context.userPreferences, step)
    context.constraintHistory = this.updateConstraints(context.constraintHistory, step)
    
    // ì»¨í…ìŠ¤íŠ¸ ì••ì¶• (ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±)
    if (context.steps.length > 20) {
      context = this.compressContext(context)
    }
    
    this.contexts.set(sessionId, context)
    return context
  }

  private deriveStateFromSteps(steps: ConversationStep[]): ProjectState {
    return steps.reduce((state, step) => {
      if (step.type === 'template:applied') {
        state.templateBase = step.data.template
      } else if (step.type === 'customization:applied') {
        state.currentCode = this.applyChanges(state.currentCode, step.data.changes)
      }
      return state
    }, this.getInitialState())
  }
}
```

### Week 5: ì œì•½ ì¡°ê±´ ì‹œìŠ¤í…œ ë° ê²€ì¦ ë¡œì§

#### ğŸ›¡ï¸ ì œì•½ ì¡°ê±´ ì—”ì§„
```typescript
class ConstraintEngine {
  private rules: ConstraintRule[] = []
  
  async validateRequest(
    analysis: RequestAnalysis,
    project: ProjectState
  ): Promise<ValidationResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    
    // ê¸°ìˆ ì  ì œì•½ ê²€ì¦
    const technicalCheck = await this.checkTechnicalConstraints(analysis, project)
    violations.push(...technicalCheck.violations)
    warnings.push(...technicalCheck.warnings)
    
    // ë””ìì¸ ì œì•½ ê²€ì¦
    const designCheck = await this.checkDesignConstraints(analysis, project)
    violations.push(...designCheck.violations)
    warnings.push(...designCheck.warnings)
    
    // ë¹„ì¦ˆë‹ˆìŠ¤ ì œì•½ ê²€ì¦
    const businessCheck = await this.checkBusinessConstraints(analysis, project)
    violations.push(...businessCheck.violations)
    warnings.push(...businessCheck.warnings)
    
    return {
      isValid: violations.length === 0,
      violations,
      warnings,
      suggestions: this.generateSuggestions(violations, warnings),
      allowedAlternatives: this.findAlternatives(analysis, violations)
    }
  }

  private async checkTechnicalConstraints(
    analysis: RequestAnalysis,
    project: ProjectState
  ): Promise<ConstraintCheckResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    
    // ì»´í¬ë„ŒíŠ¸ í˜¸í™˜ì„± ê²€ì‚¬
    if (analysis.targetComponent) {
      const component = project.templateBase.components.find(c => c.name === analysis.targetComponent)
      if (!component) {
        violations.push({
          type: 'component:not-found',
          message: `ì»´í¬ë„ŒíŠ¸ '${analysis.targetComponent}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
          severity: 'error'
        })
      } else if (!component.customizable) {
        violations.push({
          type: 'component:not-customizable',
          message: `ì»´í¬ë„ŒíŠ¸ '${analysis.targetComponent}'ëŠ” ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
          severity: 'error'
        })
      }
    }
    
    // ì˜ì¡´ì„± ê²€ì‚¬
    if (analysis.requiredFeatures) {
      for (const feature of analysis.requiredFeatures) {
        const dependency = this.checkFeatureDependency(feature, project)
        if (!dependency.available) {
          warnings.push({
            type: 'dependency:missing',
            message: `ê¸°ëŠ¥ '${feature}'ë¥¼ ìœ„í•´ ${dependency.required.join(', ')}ê°€ í•„ìš”í•©ë‹ˆë‹¤`,
            severity: 'warning'
          })
        }
      }
    }
    
    return { violations, warnings }
  }

  private async checkDesignConstraints(
    analysis: RequestAnalysis,
    project: ProjectState
  ): Promise<ConstraintCheckResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    
    // ì ‘ê·¼ì„± ê²€ì‚¬
    if (analysis.colorChanges) {
      const accessibilityCheck = await this.checkColorAccessibility(analysis.colorChanges)
      if (!accessibilityCheck.wcagCompliant) {
        warnings.push({
          type: 'accessibility:color-contrast',
          message: 'ìƒ‰ìƒ ëŒ€ë¹„ê°€ WCAG ê¸°ì¤€ì„ ì¶©ì¡±í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤',
          severity: 'warning'
        })
      }
    }
    
    // ë°˜ì‘í˜• ë””ìì¸ ê²€ì‚¬
    if (analysis.layoutChanges) {
      const responsiveCheck = this.checkResponsiveCompatibility(analysis.layoutChanges)
      if (!responsiveCheck.compatible) {
        violations.push({
          type: 'responsive:incompatible',
          message: 'ìš”ì²­í•˜ì‹  ë ˆì´ì•„ì›ƒì€ ëª¨ë°”ì¼ì—ì„œ ì ì ˆíˆ í‘œì‹œë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤',
          severity: 'error'
        })
      }
    }
    
    return { violations, warnings }
  }
}
```

## ğŸ­ Phase 3: ë¹„êµ ë° ì„ íƒ UI (2ì£¼)

### Week 6-7: ìˆ˜ì • ì „/í›„ ë¹„êµ ì‹œìŠ¤í…œ

#### ğŸ¯ ì£¼ìš” ì‘ì—…
- [ ] **ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì‹œìŠ¤í…œ**
- [ ] **ë¹„êµ WebView UI êµ¬í˜„**
- [ ] **ì„ íƒì§€ ì¸í„°ë™ì…˜ UI/UX**

#### ğŸ”„ ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ìƒì„±ê¸°
```typescript
class PreviewGenerator {
  private buildCache: Map<string, BuildResult> = new Map()
  private previewQueue: PreviewRequest[] = []
  
  async generateComparisonPreviews(
    options: CustomizationOption[],
    baseProject: ProjectState
  ): Promise<PreviewResult[]> {
    
    const previewPromises = options.map(async (option, index) => {
      const previewId = `preview-${Date.now()}-${index}`
      
      // ë³€ê²½ì‚¬í•­ ì ìš©
      const modifiedProject = await this.applyChanges(baseProject, option.changes)
      
      // ë¹Œë“œ ë° ë¯¸ë¦¬ë³´ê¸° ìƒì„±
      const buildResult = await this.buildPreview(modifiedProject, previewId)
      
      // ìŠ¤í¬ë¦°ìƒ· ìƒì„±
      const screenshot = await this.captureScreenshot(buildResult.previewUrl)
      
      return {
        optionId: option.id,
        previewId,
        previewUrl: buildResult.previewUrl,
        screenshot,
        buildTime: buildResult.duration,
        status: buildResult.status
      }
    })
    
    return Promise.all(previewPromises)
  }

  private async buildPreview(
    project: ProjectState,
    previewId: string
  ): Promise<BuildResult> {
    
    const cacheKey = this.generateCacheKey(project)
    const cached = this.buildCache.get(cacheKey)
    
    if (cached && this.isCacheValid(cached)) {
      return {
        ...cached,
        previewUrl: this.generatePreviewUrl(previewId)
      }
    }
    
    const startTime = Date.now()
    
    // ì„ì‹œ ë¹Œë“œ ë””ë ‰í† ë¦¬ ìƒì„±
    const tempDir = await this.createTempDirectory(previewId)
    
    // íŒŒì¼ ìƒì„±
    await this.generateProjectFiles(project, tempDir)
    
    // ë¹Œë“œ ì‹¤í–‰
    const buildResult = await this.buildManager.buildProject(tempDir, {
      mode: 'preview',
      optimization: false,
      sourcemap: false
    })
    
    const result = {
      previewUrl: this.deployPreview(buildResult, previewId),
      duration: Date.now() - startTime,
      status: buildResult.success ? 'success' : 'error',
      errors: buildResult.errors
    }
    
    // ìºì‹œ ì €ì¥
    this.buildCache.set(cacheKey, result)
    
    return result
  }

  private async captureScreenshot(previewUrl: string): Promise<string> {
    // ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜ ë¡œì§ (headless browser ì‚¬ìš©)
    const screenshot = await this.screenshotService.capture(previewUrl, {
      width: 1200,
      height: 800,
      format: 'webp',
      quality: 80
    })
    
    return this.uploadScreenshot(screenshot)
  }
}
```

#### ğŸ¨ ë¹„êµ WebView UI êµ¬í˜„
```typescript
// ë¹„êµ WebViewìš© React ì»´í¬ë„ŒíŠ¸
const ComparisonViewer: React.FC<ComparisonViewerProps> = ({
  originalPreview,
  options,
  onSelect,
  onRegenerate
}) => {
  const [selectedOption, setSelectedOption] = useState<string | null>(null)
  const [viewMode, setViewMode] = useState<'grid' | 'split' | 'overlay'>('grid')
  
  return (
    <div className="comparison-viewer">
      <div className="comparison-header">
        <h2>ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ ë¹„êµ</h2>
        <div className="view-controls">
          <ViewModeToggle mode={viewMode} onChange={setViewMode} />
          <RegenerateButton onClick={onRegenerate} />
        </div>
      </div>
      
      <div className={`comparison-content ${viewMode}`}>
        {/* ì›ë³¸ ë¯¸ë¦¬ë³´ê¸° */}
        <PreviewCard
          title="í˜„ì¬ ë²„ì „"
          preview={originalPreview}
          isOriginal={true}
          className="original-preview"
        />
        
        {/* ì˜µì…˜ë³„ ë¯¸ë¦¬ë³´ê¸° */}
        {options.map((option) => (
          <PreviewCard
            key={option.id}
            title={option.description}
            preview={option.preview}
            intensity={option.intensity}
            reasoning={option.reasoning}
            isSelected={selectedOption === option.id}
            onClick={() => handleOptionSelect(option.id)}
            onPreview={() => handlePreviewHover(option.id)}
          />
        ))}
      </div>
      
      <div className="comparison-actions">
        <button 
          className="btn-primary"
          disabled={!selectedOption}
          onClick={() => selectedOption && onSelect(selectedOption)}
        >
          ì„ íƒí•œ ì˜µì…˜ ì ìš©
        </button>
        <button 
          className="btn-secondary"
          onClick={() => onRegenerate()}
        >
          ë‹¤ë¥¸ ì˜µì…˜ ìƒì„±
        </button>
      </div>
    </div>
  )
}

const PreviewCard: React.FC<PreviewCardProps> = ({
  title,
  preview,
  intensity,
  reasoning,
  isOriginal,
  isSelected,
  onClick,
  onPreview
}) => {
  return (
    <div 
      className={`preview-card ${intensity} ${isSelected ? 'selected' : ''}`}
      onClick={onClick}
      onMouseEnter={onPreview}
    >
      <div className="preview-header">
        <h3>{title}</h3>
        {intensity && (
          <IntensityBadge intensity={intensity} />
        )}
      </div>
      
      <div className="preview-image">
        <img 
          src={preview.screenshot} 
          alt={title}
          loading="lazy"
        />
        <div className="preview-overlay">
          <button className="preview-fullscreen">
            ì „ì²´ í™”ë©´ìœ¼ë¡œ ë³´ê¸°
          </button>
        </div>
      </div>
      
      {reasoning && (
        <div className="preview-reasoning">
          <h4>ë³€ê²½ ì´ìœ </h4>
          <ul>
            {reasoning.map((reason, index) => (
              <li key={index}>{reason}</li>
            ))}
          </ul>
        </div>
      )}
      
      <div className="preview-metrics">
        <span>ë¹Œë“œ ì‹œê°„: {preview.buildTime}ms</span>
        <span>íŒŒì¼ í¬ê¸°: {preview.fileSize}KB</span>
      </div>
    </div>
  )
}

const IntensityBadge: React.FC<{ intensity: 'conservative' | 'balanced' | 'bold' }> = ({ intensity }) => {
  const labels = {
    conservative: 'ë³´ìˆ˜ì ',
    balanced: 'ê· í˜•ì ', 
    bold: 'ëŒ€ë‹´í•œ'
  }
  
  const colors = {
    conservative: 'bg-green-100 text-green-800',
    balanced: 'bg-blue-100 text-blue-800',
    bold: 'bg-purple-100 text-purple-800'
  }
  
  return (
    <span className={`intensity-badge ${colors[intensity]}`}>
      {labels[intensity]}
    </span>
  )
}
```

#### ğŸ¯ ì‚¬ìš©ì í”¼ë“œë°± ì‹œìŠ¤í…œ
```typescript
class UserFeedbackCollector {
  private feedbackHistory: Map<string, UserFeedback[]> = new Map()
  
  async collectSelectionFeedback(
    sessionId: string,
    selection: OptionSelection
  ): Promise<void> {
    
    const feedback: UserFeedback = {
      sessionId,
      timestamp: Date.now(),
      type: 'option:selected',
      data: {
        selectedOptionId: selection.optionId,
        selectedIntensity: selection.intensity,
        rejectedOptions: selection.rejectedOptions,
        selectionTime: selection.selectionTime,
        reasoning: selection.userReasoning
      }
    }
    
    await this.storeFeedback(feedback)
    await this.updateUserProfile(sessionId, feedback)
  }

  async collectRegenerationFeedback(
    sessionId: string,
    regeneration: RegenerationRequest
  ): Promise<void> {
    
    const feedback: UserFeedback = {
      sessionId,
      timestamp: Date.now(),
      type: 'options:regenerated',
      data: {
        originalOptions: regeneration.originalOptions,
        regenerationReason: regeneration.reason,
        specificRequests: regeneration.additionalRequests
      }
    }
    
    await this.storeFeedback(feedback)
  }

  private async updateUserProfile(sessionId: string, feedback: UserFeedback): Promise<void> {
    const profile = await this.getUserProfile(sessionId)
    
    // ì„ í˜¸ë„ íŒ¨í„´ í•™ìŠµ
    if (feedback.type === 'option:selected') {
      profile.preferredIntensity = this.updateIntensityPreference(
        profile.preferredIntensity,
        feedback.data.selectedIntensity
      )
      
      profile.designPreferences = this.updateDesignPreferences(
        profile.designPreferences,
        feedback.data
      )
    }
    
    await this.saveUserProfile(sessionId, profile)
  }
}
```

## ğŸš€ Phase 4: ìµœì í™” ë° ê³ ë„í™” (2ì£¼)

### Week 8: ì„±ëŠ¥ ìµœì í™”

#### ğŸ¯ ì£¼ìš” ì‘ì—…
- [ ] **ë¹Œë“œ ìºì‹± ì‹œìŠ¤í…œ êµ¬í˜„**
- [ ] **ë¯¸ë¦¬ë³´ê¸° ìµœì í™”**
- [ ] **ë©”ëª¨ë¦¬ ë° ë¦¬ì†ŒìŠ¤ ê´€ë¦¬**

#### âš¡ ë¹Œë“œ ìºì‹± ì‹œìŠ¤í…œ
```typescript
class BuildCacheManager {
  private cache: Map<string, CachedBuild> = new Map()
  private diskCache: DiskCacheManager
  private maxCacheSize = 100 // ìµœëŒ€ ìºì‹œ í•­ëª© ìˆ˜
  
  constructor() {
    this.diskCache = new DiskCacheManager('./cache/builds')
  }

  async getCachedBuild(cacheKey: string): Promise<CachedBuild | null> {
    // ë©”ëª¨ë¦¬ ìºì‹œ í™•ì¸
    const memoryCache = this.cache.get(cacheKey)
    if (memoryCache && this.isCacheValid(memoryCache)) {
      return memoryCache
    }
    
    // ë””ìŠ¤í¬ ìºì‹œ í™•ì¸
    const diskCache = await this.diskCache.get(cacheKey)
    if (diskCache && this.isCacheValid(diskCache)) {
      // ë©”ëª¨ë¦¬ ìºì‹œì— ë³µì›
      this.cache.set(cacheKey, diskCache)
      return diskCache
    }
    
    return null
  }

  async setCachedBuild(cacheKey: string, build: BuildResult): Promise<void> {
    const cachedBuild: CachedBuild = {
      ...build,
      cacheKey,
      createdAt: Date.now(),
      accessCount: 0,
      lastAccessed: Date.now()
    }
    
    // ë©”ëª¨ë¦¬ ìºì‹œ ì €ì¥
    this.cache.set(cacheKey, cachedBuild)
    
    // ë””ìŠ¤í¬ ìºì‹œ ì €ì¥ (ë¹„ë™ê¸°)
    this.diskCache.set(cacheKey, cachedBuild).catch(err => 
      console.warn('Failed to save disk cache:', err)
    )
    
    // ìºì‹œ í¬ê¸° ê´€ë¦¬
    await this.manageCacheSize()
  }

  generateCacheKey(project: ProjectState, options?: BuildOptions): string {
    const projectHash = this.hashProject(project)
    const optionsHash = this.hashOptions(options)
    return `${projectHash}-${optionsHash}`
  }

  private hashProject(project: ProjectState): string {
    // í”„ë¡œì íŠ¸ ìƒíƒœì˜ í•´ì‹œ ìƒì„± (íŒŒì¼ ë‚´ìš©, ì„¤ì • ë“±)
    const content = JSON.stringify({
      templateId: project.templateBase.id,
      files: this.hashFiles(project.currentCode),
      dependencies: project.dependencies,
      buildConfig: project.buildConfig
    })
    
    return this.createHash(content)
  }

  private async manageCacheSize(): Promise<void> {
    if (this.cache.size <= this.maxCacheSize) return
    
    // LRU ì •ì±…ìœ¼ë¡œ ìºì‹œ ì •ë¦¬
    const entries = Array.from(this.cache.entries())
      .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed)
    
    const toRemove = entries.slice(0, entries.length - this.maxCacheSize)
    
    for (const [key] of toRemove) {
      this.cache.delete(key)
      await this.diskCache.delete(key)
    }
  }
}
```

#### ğŸ–¼ï¸ ë¯¸ë¦¬ë³´ê¸° ìµœì í™”
```typescript
class OptimizedPreviewGenerator extends PreviewGenerator {
  private screenshotQueue: Queue<ScreenshotTask> = new Queue()
  private previewPool: PreviewPool
  
  constructor() {
    super()
    this.previewPool = new PreviewPool({
      maxConcurrent: 3,
      timeout: 30000
    })
    
    // ìŠ¤í¬ë¦°ìƒ· ì›Œì»¤ í’€ ì‹œì‘
    this.startScreenshotWorkers()
  }

  async generateOptimizedPreviews(
    options: CustomizationOption[],
    baseProject: ProjectState
  ): Promise<PreviewResult[]> {
    
    // 1. ë³€ê²½ì‚¬í•­ ë¶„ì„ìœ¼ë¡œ ë¹Œë“œ ìµœì í™”
    const changeAnalysis = this.analyzeChanges(options, baseProject)
    
    // 2. ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥í•œ ì‘ì—…ê³¼ ìˆœì°¨ ì²˜ë¦¬ ì‘ì—… ë¶„ë¦¬
    const { parallelTasks, sequentialTasks } = this.categorizeTasks(options, changeAnalysis)
    
    // 3. ë³‘ë ¬ ì²˜ë¦¬
    const parallelResults = await Promise.all(
      parallelTasks.map(task => this.processPreviewTask(task))
    )
    
    // 4. ìˆœì°¨ ì²˜ë¦¬ (ì˜ì¡´ì„±ì´ ìˆëŠ” ì‘ì—…ë“¤)
    const sequentialResults = []
    for (const task of sequentialTasks) {
      const result = await this.processPreviewTask(task)
      sequentialResults.push(result)
    }
    
    return [...parallelResults, ...sequentialResults]
  }

  private analyzeChanges(
    options: CustomizationOption[],
    baseProject: ProjectState
  ): ChangeAnalysis {
    
    return {
      affectedComponents: this.findAffectedComponents(options),
      styleChanges: this.extractStyleChanges(options),
      structuralChanges: this.extractStructuralChanges(options),
      assetChanges: this.extractAssetChanges(options),
      
      // ìµœì í™” íŒíŠ¸
      canUseHotReload: this.canUseHotReload(options),
      canShareAssets: this.canShareAssets(options),
      canReuseLayout: this.canReuseLayout(options)
    }
  }

  private async processPreviewTask(task: PreviewTask): Promise<PreviewResult> {
    const instance = await this.previewPool.acquire()
    
    try {
      // í•« ë¦¬ë¡œë“œ ê°€ëŠ¥í•œ ê²½ìš° ìµœì í™”ëœ ë¹Œë“œ
      if (task.analysis.canUseHotReload) {
        return await this.generateHotReloadPreview(task, instance)
      }
      
      // ì¼ë°˜ ë¹Œë“œ
      return await this.generateFullPreview(task, instance)
      
    } finally {
      this.previewPool.release(instance)
    }
  }

  private async generateHotReloadPreview(
    task: PreviewTask,
    instance: PreviewInstance
  ): Promise<PreviewResult> {
    
    // ê¸°ì¡´ ë¹Œë“œ ì¬ì‚¬ìš©í•˜ê³  ë³€ê²½ì‚¬í•­ë§Œ ì ìš©
    const baseUrl = await this.getBaseBuildUrl(task.baseProject)
    
    // CSS/JS ì¸ì ì…˜ìœ¼ë¡œ ë³€ê²½ì‚¬í•­ ì ìš©
    const modifications = await this.generateModifications(task.option.changes)
    
    const previewUrl = await instance.applyHotReload(baseUrl, modifications)
    
    // ê°€ë²¼ìš´ ìŠ¤í¬ë¦°ìƒ· (ë·°í¬íŠ¸ë§Œ)
    const screenshot = await this.captureViewportScreenshot(previewUrl)
    
    return {
      optionId: task.option.id,
      previewUrl,
      screenshot,
      buildTime: 50, // í•« ë¦¬ë¡œë“œëŠ” ë§¤ìš° ë¹ ë¦„
      status: 'success',
      optimized: true
    }
  }
}
```

### Week 9: ì‚¬ìš©ì í•™ìŠµ ê¸°ë°˜ ì¶”ì²œ ê°œì„  ë° A/B í…ŒìŠ¤íŠ¸

#### ğŸ¯ ì£¼ìš” ì‘ì—…
- [ ] **ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„**
- [ ] **ê°œì¸í™”ëœ ì¶”ì²œ ì‹œìŠ¤í…œ**
- [ ] **A/B í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬**
- [ ] **ì„±ëŠ¥ ë¶„ì„ ë° ê°œì„ ì‚¬í•­ ë„ì¶œ**

#### ğŸ§  ì‚¬ìš©ì í•™ìŠµ ì‹œìŠ¤í…œ
```typescript
class UserLearningSystem {
  private behaviorAnalyzer: BehaviorAnalyzer
  private recommendationEngine: PersonalizedRecommendationEngine
  private abTestManager: ABTestManager
  
  constructor() {
    this.behaviorAnalyzer = new BehaviorAnalyzer()
    this.recommendationEngine = new PersonalizedRecommendationEngine()
    this.abTestManager = new ABTestManager()
  }

  async analyzeUserBehavior(userId: string): Promise<UserBehaviorProfile> {
    const rawData = await this.getUserInteractionData(userId)
    
    return {
      preferredIntensity: this.calculateIntensityPreference(rawData),
      designPatterns: this.identifyDesignPatterns(rawData),
      decisionSpeed: this.calculateDecisionSpeed(rawData),
      explorationTendency: this.calculateExplorationTendency(rawData),
      
      // ì‹œê°„ë³„ íŒ¨í„´
      timeBasedPreferences: this.analyzeTimePatterns(rawData),
      
      // ì»¨í…ìŠ¤íŠ¸ë³„ íŒ¨í„´
      contextualPreferences: this.analyzeContextualPatterns(rawData),
      
      // ë§Œì¡±ë„ íŒ¨í„´
      satisfactionIndicators: this.analyzeSatisfactionPatterns(rawData)
    }
  }

  private calculateIntensityPreference(data: UserInteractionData[]): IntensityPreference {
    const selections = data.filter(d => d.type === 'option:selected')
    const intensityCounts = {
      conservative: 0,
      balanced: 0,
      bold: 0
    }
    
    selections.forEach(selection => {
      intensityCounts[selection.data.intensity]++
    })
    
    const total = selections.length
    return {
      conservative: intensityCounts.conservative / total,
      balanced: intensityCounts.balanced / total,
      bold: intensityCounts.bold / total,
      
      // ì‹ ë¢°ë„ (ì„ íƒ íšŸìˆ˜ê°€ ë§ì„ìˆ˜ë¡ ë†’ìŒ)
      confidence: Math.min(total / 20, 1.0)
    }
  }

  private identifyDesignPatterns(data: UserInteractionData[]): DesignPattern[] {
    const patterns = []
    
    // ìƒ‰ìƒ ì„ í˜¸ë„ íŒ¨í„´
    const colorChoices = this.extractColorChoices(data)
    if (colorChoices.length > 5) {
      patterns.push({
        type: 'color_preference',
        pattern: this.analyzeColorPreferences(colorChoices),
        confidence: 0.8
      })
    }
    
    // ë ˆì´ì•„ì›ƒ ì„ í˜¸ë„ íŒ¨í„´
    const layoutChoices = this.extractLayoutChoices(data)
    if (layoutChoices.length > 3) {
      patterns.push({
        type: 'layout_preference',
        pattern: this.analyzeLayoutPreferences(layoutChoices),
        confidence: 0.7
      })
    }
    
    // íƒ€ì´í¬ê·¸ë˜í”¼ íŒ¨í„´
    const typographyChoices = this.extractTypographyChoices(data)
    if (typographyChoices.length > 3) {
      patterns.push({
        type: 'typography_preference',
        pattern: this.analyzeTypographyPreferences(typographyChoices),
        confidence: 0.6
      })
    }
    
    return patterns
  }
}
```

#### ğŸ¯ ê°œì¸í™”ëœ ì¶”ì²œ ì—”ì§„
```typescript
class PersonalizedRecommendationEngine extends TemplateRecommendationEngine {
  async generatePersonalizedRecommendations(
    query: string,
    userProfile: UserBehaviorProfile,
    context: RecommendationContext
  ): Promise<PersonalizedRecommendation[]> {
    
    // 1. ê¸°ë³¸ ì¶”ì²œ ìƒì„±
    const baseRecommendations = await super.recommendTemplates(query)
    
    // 2. ì‚¬ìš©ì í”„ë¡œí•„ ê¸°ë°˜ ê°€ì¤‘ì¹˜ ì¡°ì •
    const personalizedScores = baseRecommendations.map(rec => ({
      ...rec,
      personalizedScore: this.calculatePersonalizedScore(rec, userProfile, context),
      personalizedReasons: this.generatePersonalizedReasons(rec, userProfile)
    }))
    
    // 3. A/B í…ŒìŠ¤íŠ¸ ì ìš©
    const abTestVariant = await this.abTestManager.getVariant('recommendation_order', context.userId)
    const finalRecommendations = this.applyABTestVariant(personalizedScores, abTestVariant)
    
    return finalRecommendations
  }

  private calculatePersonalizedScore(
    recommendation: TemplateRecommendation,
    profile: UserBehaviorProfile,
    context: RecommendationContext
  ): number {
    
    let score = recommendation.confidence
    
    // ì‹œê°„ ê¸°ë°˜ ì¡°ì •
    const timeBoost = this.getTimeBasedBoost(recommendation, profile.timeBasedPreferences, context.currentTime)
    score *= (1 + timeBoost * 0.1)
    
    // ì„¤ê³„ íŒ¨í„´ ë§¤ì¹­
    const patternBoost = this.getPatternMatchBoost(recommendation, profile.designPatterns)
    score *= (1 + patternBoost * 0.15)
    
    // ê°•ë„ ì„ í˜¸ë„ ë§¤ì¹­
    const intensityBoost = this.getIntensityBoost(recommendation, profile.preferredIntensity)
    score *= (1 + intensityBoost * 0.1)
    
    // íƒí—˜ vs í™œìš© ê· í˜•
    const explorationBoost = this.getExplorationBoost(recommendation, profile.explorationTendency, context)
    score *= (1 + explorationBoost * 0.05)
    
    return Math.min(score, 1.0)
  }

  private generatePersonalizedReasons(
    recommendation: TemplateRecommendation,
    profile: UserBehaviorProfile
  ): string[] {
    
    const reasons = [...recommendation.reasons]
    
    // ê°œì¸í™”ëœ ì´ìœ  ì¶”ê°€
    if (profile.preferredIntensity.bold > 0.6) {
      reasons.push('ëŒ€ë‹´í•œ ë””ìì¸ì„ ì„ í˜¸í•˜ì‹œëŠ” ì„±í–¥ì— ë§ìŠµë‹ˆë‹¤')
    }
    
    const dominantPattern = profile.designPatterns
      .sort((a, b) => b.confidence - a.confidence)[0]
    
    if (dominantPattern && this.templateMatchesPattern(recommendation.template, dominantPattern)) {
      reasons.push(`ìì£¼ ì„ íƒí•˜ì‹œëŠ” ${dominantPattern.type} ìŠ¤íƒ€ì¼ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤`)
    }
    
    return reasons
  }
}
```

#### ğŸ§ª A/B í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬
```typescript
class ABTestManager {
  private experiments: Map<string, ABExperiment> = new Map()
  private userAssignments: Map<string, Map<string, string>> = new Map()
  
  async createExperiment(experiment: ABExperiment): Promise<void> {
    this.experiments.set(experiment.id, experiment)
    await this.persistExperiment(experiment)
  }

  async getVariant(experimentId: string, userId: string): Promise<string> {
    const experiment = this.experiments.get(experimentId)
    if (!experiment || !experiment.active) {
      return 'control'
    }
    
    // ì‚¬ìš©ìë³„ ì¼ê´€ëœ ë°°ì •
    let userExperiments = this.userAssignments.get(userId)
    if (!userExperiments) {
      userExperiments = new Map()
      this.userAssignments.set(userId, userExperiments)
    }
    
    let assignedVariant = userExperiments.get(experimentId)
    if (!assignedVariant) {
      assignedVariant = this.assignVariant(experiment, userId)
      userExperiments.set(experimentId, assignedVariant)
      await this.logAssignment(experimentId, userId, assignedVariant)
    }
    
    return assignedVariant
  }

  private assignVariant(experiment: ABExperiment, userId: string): string {
    // ì‚¬ìš©ì ID ê¸°ë°˜ í•´ì‹œë¡œ ì¼ê´€ëœ ë°°ì •
    const hash = this.hashUserId(userId + experiment.id)
    const random = (hash % 100) / 100
    
    let cumulative = 0
    for (const variant of experiment.variants) {
      cumulative += variant.trafficAllocation
      if (random < cumulative) {
        return variant.id
      }
    }
    
    return 'control'
  }

  async recordEvent(
    experimentId: string,
    userId: string,
    eventType: string,
    eventData: any
  ): Promise<void> {
    
    const variant = await this.getVariant(experimentId, userId)
    
    const event: ABTestEvent = {
      experimentId,
      userId,
      variant,
      eventType,
      eventData,
      timestamp: Date.now()
    }
    
    await this.persistEvent(event)
  }

  async getExperimentResults(experimentId: string): Promise<ExperimentResults> {
    const events = await this.getExperimentEvents(experimentId)
    const variants = this.experiments.get(experimentId)?.variants || []
    
    const results: ExperimentResults = {
      experimentId,
      totalUsers: new Set(events.map(e => e.userId)).size,
      variants: variants.map(variant => ({
        variantId: variant.id,
        users: new Set(events.filter(e => e.variant === variant.id).map(e => e.userId)).size,
        events: events.filter(e => e.variant === variant.id),
        metrics: this.calculateVariantMetrics(events.filter(e => e.variant === variant.id))
      })),
      statisticalSignificance: this.calculateSignificance(events, variants)
    }
    
    return results
  }
}

// A/B í…ŒìŠ¤íŠ¸ ì‹¤í—˜ ì •ì˜ ì˜ˆì‹œ
const recommendationOrderExperiment: ABExperiment = {
  id: 'recommendation_order',
  name: 'ì¶”ì²œ ìˆœì„œ ìµœì í™”',
  description: 'ê°œì¸í™” ì ìˆ˜ vs ì¼ë°˜ ì ìˆ˜ ê¸°ë°˜ ì¶”ì²œ ìˆœì„œ ë¹„êµ',
  active: true,
  startDate: Date.now(),
  endDate: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30ì¼
  
  variants: [
    {
      id: 'control',
      name: 'ê¸°ë³¸ ì¶”ì²œ',
      trafficAllocation: 0.5,
      config: { usePersonalization: false }
    },
    {
      id: 'personalized',
      name: 'ê°œì¸í™” ì¶”ì²œ',
      trafficAllocation: 0.5,
      config: { usePersonalization: true }
    }
  ],
  
  metrics: [
    { name: 'template_selection_rate', type: 'conversion' },
    { name: 'time_to_selection', type: 'duration' },
    { name: 'user_satisfaction', type: 'rating' }
  ]
}
```

#### ğŸ“Š ì„±ëŠ¥ ë¶„ì„ ë° ê°œì„ ì‚¬í•­ ë„ì¶œ
```typescript
class PerformanceAnalyzer {
  async generateImplementationReport(): Promise<ImplementationReport> {
    const metrics = await this.collectMetrics()
    const userFeedback = await this.analyzeFeedback()
    const technicalMetrics = await this.analyzeTechnicalPerformance()
    
    return {
      summary: this.generateSummary(metrics, userFeedback, technicalMetrics),
      userExperience: {
        satisfactionScore: userFeedback.averageSatisfaction,
        completionRate: metrics.workflowCompletionRate,
        averageSessionDuration: metrics.averageSessionDuration,
        returnUserRate: metrics.returnUserRate
      },
      technicalPerformance: {
        averageBuildTime: technicalMetrics.averageBuildTime,
        cacheHitRate: technicalMetrics.cacheHitRate,
        errorRate: technicalMetrics.errorRate,
        systemUptime: technicalMetrics.uptime
      },
      aiPerformance: {
        intentAccuracy: metrics.intentRecognitionAccuracy,
        recommendationRelevance: metrics.recommendationRelevance,
        customizationSatisfaction: metrics.customizationSatisfaction
      },
      improvements: this.generateImprovementRecommendations(metrics, userFeedback, technicalMetrics)
    }
  }

  private generateImprovementRecommendations(
    metrics: SystemMetrics,
    feedback: UserFeedback,
    technical: TechnicalMetrics
  ): ImprovementRecommendation[] {
    
    const recommendations = []
    
    // ì„±ëŠ¥ ê°œì„ 
    if (technical.averageBuildTime > 5000) {
      recommendations.push({
        category: 'performance',
        priority: 'high',
        title: 'ë¹Œë“œ ì‹œê°„ ìµœì í™”',
        description: 'í‰ê·  ë¹Œë“œ ì‹œê°„ì´ 5ì´ˆë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤',
        actions: [
          'ì¦ë¶„ ë¹Œë“œ ì‹œìŠ¤í…œ ë„ì…',
          'ë³‘ë ¬ ì²˜ë¦¬ ìµœì í™”',
          'ë¶ˆí•„ìš”í•œ dependency ì œê±°'
        ]
      })
    }
    
    // ì‚¬ìš©ì ê²½í—˜ ê°œì„ 
    if (feedback.averageSatisfaction < 4.0) {
      recommendations.push({
        category: 'ux',
        priority: 'medium',
        title: 'ì‚¬ìš©ì ë§Œì¡±ë„ ê°œì„ ',
        description: 'ì‚¬ìš©ì ë§Œì¡±ë„ê°€ ëª©í‘œì¹˜(4.5)ë³´ë‹¤ ë‚®ìŠµë‹ˆë‹¤',
        actions: [
          'UI/UX ê°œì„ ',
          'ë” ì •í™•í•œ AI ì¶”ì²œ',
          'ì‚¬ìš©ì ì˜¨ë³´ë”© ê°œì„ '
        ]
      })
    }
    
    // AI ì •í™•ë„ ê°œì„ 
    if (metrics.intentRecognitionAccuracy < 0.85) {
      recommendations.push({
        category: 'ai',
        priority: 'high',
        title: 'AI ì˜ë„ íŒŒì•… ì •í™•ë„ ê°œì„ ',
        description: 'ì˜ë„ íŒŒì•… ì •í™•ë„ê°€ ëª©í‘œì¹˜(85%)ë³´ë‹¤ ë‚®ìŠµë‹ˆë‹¤',
        actions: [
          'í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ê°œì„ ',
          'ë” ë§ì€ í•™ìŠµ ë°ì´í„° ìˆ˜ì§‘',
          'ì»¨í…ìŠ¤íŠ¸ ì´í•´ ì•Œê³ ë¦¬ì¦˜ ê°œì„ '
        ]
      })
    }
    
    return recommendations
  }
}
```

## ğŸ“ˆ ì„±ê³µ ì§€í‘œ (KPIs)

### ğŸ“Š Phaseë³„ ì„±ê³µ ì§€í‘œ

#### Phase 1: í…œí”Œë¦¿ ì‹œìŠ¤í…œ
- **ì™„ë£Œìœ¨**: ëª¨ë“  ê¸°ë³¸ í…œí”Œë¦¿ 5ê°œ ì œì‘ ì™„ë£Œ
- **í’ˆì§ˆ**: ê° í…œí”Œë¦¿ì˜ ë°˜ì‘í˜• ë””ìì¸ í˜¸í™˜ì„± 100%
- **ì„±ëŠ¥**: í…œí”Œë¦¿ ë¡œë”© ì‹œê°„ < 2ì´ˆ

#### Phase 2: ëŒ€í™”í˜• ì»¤ìŠ¤í„°ë§ˆì´ì§•
- **ì •í™•ë„**: AI ì˜ë„ íŒŒì•… ì •í™•ë„ > 80%
- **ë§Œì¡±ë„**: ìƒì„±ëœ ì˜µì…˜ì— ëŒ€í•œ ì‚¬ìš©ì ë§Œì¡±ë„ > 4.0/5.0
- **ì™„ì„±ë„**: ì œì•½ ì¡°ê±´ ìœ„ë°˜ìœ¨ < 5%

#### Phase 3: ë¹„êµ ë° ì„ íƒ UI
- **ì‚¬ìš©ì„±**: ì˜µì…˜ ì„ íƒ ì™„ë£Œìœ¨ > 90%
- **ì„±ëŠ¥**: ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì‹œê°„ < 10ì´ˆ
- **ë§Œì¡±ë„**: UI/UX ë§Œì¡±ë„ > 4.2/5.0

#### Phase 4: ìµœì í™” ë° ê³ ë„í™”
- **ì„±ëŠ¥**: ë¹Œë“œ ìºì‹œ íˆíŠ¸ìœ¨ > 60%
- **ê°œì¸í™”**: ê°œì¸í™” ì¶”ì²œ ì •í™•ë„ > 85%
- **ì•ˆì •ì„±**: ì‹œìŠ¤í…œ ì—…íƒ€ì„ > 99.5%

## ğŸ”§ ê¸°ìˆ  ìŠ¤íƒ ë° ë„êµ¬

### ğŸ—ï¸ í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ
- **Frontend**: React 18+ TypeScript, Tailwind CSS
- **Backend**: Node.js, Express, TypeScript
- **AI/ML**: OpenAI GPT-4, LangChain, Custom Prompt Engineering
- **ë¹Œë“œ ì‹œìŠ¤í…œ**: Webpack 5, Vite (ê°œë°œí™˜ê²½)
- **ìºì‹±**: Redis, File System Cache
- **ë°ì´í„°ë² ì´ìŠ¤**: PostgreSQL (ì‚¬ìš©ì ë°ì´í„°), SQLite (ìºì‹œ)

### ğŸ› ï¸ ê°œë°œ ë„êµ¬
- **ê°œë°œí™˜ê²½**: VS Code, WindWalker Extension
- **í…ŒìŠ¤íŒ…**: Jest, Playwright, Storybook
- **ëª¨ë‹ˆí„°ë§**: Winston (ë¡œê¹…), Prometheus (ë©”íŠ¸ë¦­)
- **ë°°í¬**: Docker, GitHub Actions

## ğŸš€ ë°°í¬ ë° ë¡¤ì•„ì›ƒ ê³„íš

### ğŸ“… ë°°í¬ ì¼ì •
- **Week 1-2**: Phase 1 ê°œë°œ ë° ë‚´ë¶€ í…ŒìŠ¤íŠ¸
- **Week 3-5**: Phase 2 ê°œë°œ ë° ì•ŒíŒŒ í…ŒìŠ¤íŠ¸ (ë‚´ë¶€ ì‚¬ìš©ì)
- **Week 6-7**: Phase 3 ê°œë°œ ë° ë² íƒ€ í…ŒìŠ¤íŠ¸ (ì œí•œëœ ì™¸ë¶€ ì‚¬ìš©ì)
- **Week 8-9**: Phase 4 ê°œë°œ ë° í”„ë¡œë•ì…˜ ì¤€ë¹„
- **Week 10**: ê³µì‹ ë¦´ë¦¬ìŠ¤

### ğŸ¯ ë¡¤ì•„ì›ƒ ì „ëµ
1. **ë‚´ë¶€ í…ŒìŠ¤íŠ¸** (Week 1-5): ê°œë°œíŒ€ ë° QAíŒ€ í…ŒìŠ¤íŠ¸
2. **í´ë¡œì¦ˆ ë² íƒ€** (Week 6-7): ì„ ë³„ëœ íŒŒì›Œ ìœ ì € 50ëª…
3. **ì˜¤í”ˆ ë² íƒ€** (Week 8-9): ì¼ë°˜ ì‚¬ìš©ì 500ëª… ì œí•œ
4. **ë‹¨ê³„ì  ë¦´ë¦¬ìŠ¤** (Week 10): ì „ì²´ ì‚¬ìš©ì ëŒ€ìƒ ìˆœì°¨ ë°°í¬

ì´ êµ¬í˜„ ê³„íšì„ í†µí•´ WindWalkerëŠ” ì‹œì¥ì—ì„œ ì°¨ë³„í™”ëœ AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë”ë¡œ ìë¦¬ì¡ì„ ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤. ê° Phaseë³„ë¡œ ì² ì €í•œ í…ŒìŠ¤íŠ¸ì™€ ì‚¬ìš©ì í”¼ë“œë°±ì„ ìˆ˜ì§‘í•˜ì—¬ ì§€ì†ì ìœ¼ë¡œ ê°œì„ í•´ë‚˜ê°€ê² ìŠµë‹ˆë‹¤.