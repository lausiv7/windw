# WindWalker AI 대화식 웹사이트 빌더 워크플로우 구현 문서

## 📋 구현 개요

이 문서는 WindWalker 중앙 허브 아키텍처에 AI 대화식 웹사이트 빌더를 통합하는 9주간의 구현 계획을 제시합니다.

**핵심 통합 원칙**: 기존 MessageBridge 중심 아키텍처를 확장하여 AI 워크플로우를 seamless하게 통합

12 WindWalker AI 대화식 웹사이트 빌더 통합 설계 문서에 근거하여, 
통합 전의  11 AI 대화식 웹사이트 빌더 워크플로우 설계 문서대로 작성된,
13 AI 대화식 웹사이트 빌더 워크플로우 구현 문서

Phase 1: 템플릿 시스템 (2주)
* [ ] 템플릿 메타데이터 구조 설계
* [ ] 기본 템플릿 5개 제작 (블로그, 쇼핑몰, 포트폴리오, 카페, 회사소개)
* [ ] 템플릿 추천 엔진 구현
* [ ] 의도 파악 AI 프롬프트 개발
Phase 2: 대화형 커스터마이징 (3주)
* [ ] ConversationalCustomizer 구현
* [ ] 제약 조건 시스템 구축
* [ ] 변경사항 검증 로직
* [ ] 대안 생성 알고리즘
Phase 3: 비교 및 선택 UI (2주)
* [ ] 수정 전/후 비교 WebView
* [ ] 실시간 미리보기 생성
* [ ] 선택지 UI/UX 구현
* [ ] 사용자 피드백 시스템
Phase 4: 최적화 및 고도화 (2주)
* [ ] 성능 최적화 (빌드 캐싱, 미리보기 최적화)
* [ ] 사용자 학습 기반 추천 개선
* [ ] A/B 테스트 기능
* [ ] 분석 및 개선사항 도출




## 🚀 Phase 1: 템플릿 시스템 (2주)

### Week 1: 템플릿 메타데이터 구조 및 기본 템플릿 제작

#### 🎯 주요 작업
- [ ] **템플릿 메타데이터 구조 설계**
- [ ] **기본 템플릿 5개 제작**
- [ ] **TemplateManager 컴포넌트 구현**

#### 📊 템플릿 메타데이터 구조
```typescript
interface TemplateMetadata {
  id: string
  name: string
  category: 'blog' | 'ecommerce' | 'portfolio' | 'restaurant' | 'corporate'
  description: string
  tags: string[]
  difficulty: 'beginner' | 'intermediate' | 'advanced'
  
  // AI 워크플로우용 메타데이터
  customizationPoints: CustomizationPoint[]
  constraints: DesignConstraints
  recommendedFor: UserProfile[]
  
  // 기술적 메타데이터
  components: ComponentInfo[]
  dependencies: string[]
  buildConfig: BuildConfiguration
  
  // 비즈니스 메타데이터
  industry: string[]
  targetAudience: string[]
  keyFeatures: string[]
}

interface CustomizationPoint {
  id: string
  name: string
  type: 'color' | 'layout' | 'content' | 'component' | 'style'
  description: string
  constraints: PointConstraints
  aiPromptHints: string[]
}
```

#### 🏗️ 기본 템플릿 5개 상세 스펙

##### 1. 블로그 템플릿 ("Modern Blog")
```typescript
const blogTemplate: TemplateMetadata = {
  id: 'blog-modern-001',
  name: 'Modern Blog',
  category: 'blog',
  description: '깔끔하고 읽기 쉬운 현대적 블로그 템플릿',
  tags: ['responsive', 'seo-friendly', 'dark-mode'],
  
  customizationPoints: [
    {
      id: 'header-style',
      name: '헤더 스타일',
      type: 'layout',
      description: '헤더 레이아웃과 네비게이션 스타일',
      constraints: { 
        allowedLayouts: ['centered', 'left-aligned', 'split'],
        maxMenuItems: 7 
      },
      aiPromptHints: ['네비게이션', '로고 위치', '메뉴 스타일']
    },
    {
      id: 'color-scheme',
      name: '컬러 스킴',
      type: 'color',
      description: '전체 사이트 색상 테마',
      constraints: {
        primaryColors: 'unlimited',
        contrastRatio: 'WCAG-AA'
      },
      aiPromptHints: ['브랜드 컬러', '다크모드', 'accent 컬러']
    }
  ],
  
  components: [
    { name: 'Header', customizable: true, required: true },
    { name: 'PostGrid', customizable: true, required: true },
    { name: 'Sidebar', customizable: true, required: false },
    { name: 'Footer', customizable: true, required: true }
  ]
}
```

##### 2. 쇼핑몰 템플릿 ("E-commerce Pro")
```typescript
const ecommerceTemplate: TemplateMetadata = {
  id: 'ecommerce-pro-001',
  name: 'E-commerce Pro',
  category: 'ecommerce',
  description: '전문적인 온라인 쇼핑몰 템플릿',
  tags: ['cart', 'payment', 'product-showcase'],
  
  customizationPoints: [
    {
      id: 'product-layout',
      name: '상품 진열 방식',
      type: 'layout',
      description: '상품을 표시하는 그리드 레이아웃',
      constraints: {
        gridOptions: [2, 3, 4, 6],
        cardStyles: ['minimal', 'detailed', 'hover-effect']
      },
      aiPromptHints: ['상품 그리드', '카드 디자인', '호버 효과']
    }
  ]
}
```

##### 3. 포트폴리오 템플릿 ("Creative Portfolio")
```typescript
const portfolioTemplate: TemplateMetadata = {
  id: 'portfolio-creative-001',
  name: 'Creative Portfolio',
  category: 'portfolio',
  description: '창작자를 위한 포트폴리오 템플릿',
  tags: ['gallery', 'animation', 'showcase']
}
```

##### 4. 카페 템플릿 ("Cozy Cafe")
```typescript
const cafeTemplate: TemplateMetadata = {
  id: 'cafe-cozy-001',
  name: 'Cozy Cafe',
  category: 'restaurant',
  description: '따뜻한 분위기의 카페 웹사이트',
  tags: ['menu', 'location', 'warm-design']
}
```

##### 5. 회사소개 템플릿 ("Corporate Clean")
```typescript
const corporateTemplate: TemplateMetadata = {
  id: 'corporate-clean-001',
  name: 'Corporate Clean',
  category: 'corporate',
  description: '신뢰감 있는 기업 소개 페이지',
  tags: ['professional', 'team', 'services']
}
```

#### 🔧 TemplateManager 구현
```typescript
class TemplateManager {
  private templates: Map<string, TemplateMetadata> = new Map()
  private templateFiles: Map<string, TemplateFiles> = new Map()

  constructor(
    private fileManager: FileManager,
    private aiContextManager: AIContextManager
  ) {}

  async loadTemplate(templateId: string): Promise<TemplateFiles> {
    const cached = this.templateFiles.get(templateId)
    if (cached) return cached

    const template = await this.fileManager.readTemplateFiles(templateId)
    this.templateFiles.set(templateId, template)
    return template
  }

  async recommendTemplates(userInput: string): Promise<TemplateRecommendation[]> {
    const intent = await this.aiContextManager.analyzeIntent(userInput)
    const matching = this.findMatchingTemplates(intent)
    
    return matching.map(template => ({
      template,
      confidence: this.calculateConfidence(intent, template),
      reasons: this.generateReasons(intent, template)
    }))
  }

  private findMatchingTemplates(intent: UserIntent): TemplateMetadata[] {
    return Array.from(this.templates.values())
      .filter(template => this.matchesIntent(template, intent))
      .sort((a, b) => this.calculateRelevance(b, intent) - this.calculateRelevance(a, intent))
      .slice(0, 3)
  }
}
```

### Week 2: 템플릿 추천 엔진 및 의도 파악 AI

#### 🎯 주요 작업
- [ ] **의도 파악 AI 프롬프트 개발**
- [ ] **템플릿 추천 알고리즘 구현**
- [ ] **MessageBridge AI 라우터 통합**

#### 🧠 의도 파악 AI 프롬프트 시스템
```typescript
class IntentAnalyzer {
  private intentPrompts = {
    classification: `
사용자 입력을 분석하여 웹사이트 유형을 분류해주세요.

입력: "${userInput}"

분류 기준:
1. 비즈니스 유형: [blog, ecommerce, portfolio, restaurant, corporate, landing, community]
2. 주요 목적: [showcase, sales, information, engagement, branding]
3. 타겟 대상: [personal, business, organization, creative, technical]
4. 필수 기능: 사용자가 언급한 구체적 기능들
5. 디자인 선호: 언급된 스타일, 색상, 레이아웃 선호도

JSON 형태로 응답해주세요:
{
  "businessType": "...",
  "purpose": "...",
  "target": "...",
  "requiredFeatures": [...],
  "designPreferences": {...},
  "confidence": 0.85
}
    `,
    
    refinement: `
사용자의 수정 요청을 분석해주세요.

현재 템플릿: ${currentTemplate}
사용자 요청: "${userInput}"

분석 결과:
1. 수정 대상: [header, content, layout, colors, components, functionality]
2. 수정 유형: [style, content, structure, behavior]
3. 구체성 수준: [vague, specific, detailed]
4. 실현 가능성: [easy, medium, complex, impossible]

제약 조건 내에서 가능한 수정사항과 대안을 제시해주세요.
    `
  }

  async analyzeUserIntent(input: string, context?: ConversationContext): Promise<UserIntent> {
    const prompt = this.buildContextualPrompt(input, context)
    const response = await this.callLLM(prompt)
    return this.parseIntentResponse(response)
  }
}
```

#### 🎯 템플릿 추천 알고리즘
```typescript
class TemplateRecommendationEngine {
  calculateTemplateScore(template: TemplateMetadata, intent: UserIntent): number {
    let score = 0
    
    // 비즈니스 타입 매칭 (40%)
    if (template.category === intent.businessType) {
      score += 0.4
    }
    
    // 기능 매칭 (30%)
    const featureMatch = this.calculateFeatureMatch(template.keyFeatures, intent.requiredFeatures)
    score += featureMatch * 0.3
    
    // 타겟 대상 매칭 (20%)
    const audienceMatch = this.calculateAudienceMatch(template.targetAudience, intent.target)
    score += audienceMatch * 0.2
    
    // 디자인 선호도 매칭 (10%)
    const styleMatch = this.calculateStyleMatch(template.tags, intent.designPreferences)
    score += styleMatch * 0.1
    
    return Math.min(score, 1.0)
  }

  generateRecommendationReasons(template: TemplateMetadata, intent: UserIntent): string[] {
    const reasons = []
    
    if (template.category === intent.businessType) {
      reasons.push(`${intent.businessType} 카테고리에 최적화되어 있습니다`)
    }
    
    const matchingFeatures = template.keyFeatures.filter(feature => 
      intent.requiredFeatures.some(required => 
        this.isFeatureMatch(feature, required)
      )
    )
    
    if (matchingFeatures.length > 0) {
      reasons.push(`요청하신 ${matchingFeatures.join(', ')} 기능을 제공합니다`)
    }
    
    return reasons
  }
}
```

#### 🔗 MessageBridge 통합
```typescript
// 기존 MessageBridge 확장
class EnhancedMessageBridge extends MessageBridge {
  private templateManager: TemplateManager
  private intentAnalyzer: IntentAnalyzer
  
  async handleAIWorkflowMessage(message: AIWorkflowMessage): Promise<void> {
    switch (message.workflowType) {
      case 'template:search':
        await this.handleTemplateSearch(message)
        break
      case 'template:apply':
        await this.handleTemplateApplication(message)
        break
      case 'intent:analyze':
        await this.handleIntentAnalysis(message)
        break
    }
  }

  private async handleTemplateSearch(message: TemplateSearchMessage): Promise<void> {
    const recommendations = await this.templateManager.recommendTemplates(message.query)
    
    this.postToWebView('ai-chat', {
      type: 'template:recommendations',
      data: {
        query: message.query,
        templates: recommendations,
        timestamp: Date.now()
      }
    })
  }
}
```

## 🎨 Phase 2: 대화형 커스터마이징 (3주)

### Week 3-4: ConversationalCustomizer 구현

#### 🎯 주요 작업
- [ ] **ConversationalCustomizer 핵심 엔진 개발**
- [ ] **컨텍스트 기반 대화 관리**
- [ ] **단계별 커스터마이징 워크플로우**

#### 🤖 ConversationalCustomizer 구현
```typescript
class ConversationalCustomizer {
  private conversationHistory: ConversationStep[] = []
  private currentProject: ProjectState
  private constraintEngine: ConstraintEngine

  constructor(
    private codeGenerationService: CodeGenerationService,
    private buildManager: BuildManager,
    private aiContextManager: AIContextManager
  ) {}

  async processCustomizationRequest(
    request: CustomizationRequest,
    context: ConversationContext
  ): Promise<CustomizationResponse> {
    
    // 1. 요청 분석 및 검증
    const analysis = await this.analyzeRequest(request, context)
    
    // 2. 제약 조건 확인
    const constraints = await this.constraintEngine.validateRequest(analysis, this.currentProject)
    
    if (!constraints.isValid) {
      return this.generateConstraintResponse(constraints)
    }
    
    // 3. 커스터마이징 옵션 생성
    const options = await this.generateCustomizationOptions(analysis, constraints)
    
    // 4. 미리보기 생성
    const previews = await this.generatePreviews(options)
    
    // 5. 응답 구성
    return {
      type: 'customization:options',
      options: options.map((option, index) => ({
        id: `option-${Date.now()}-${index}`,
        description: option.description,
        changes: option.changes,
        previewUrl: previews[index],
        intensity: option.intensity,
        reasoning: option.reasoning
      })),
      context: this.updateContext(context, analysis)
    }
  }

  private async generateCustomizationOptions(
    analysis: RequestAnalysis,
    constraints: ValidationResult
  ): Promise<CustomizationOption[]> {
    
    const prompts = this.buildCustomizationPrompts(analysis, constraints)
    
    // 3가지 강도별 옵션 생성
    const options = await Promise.all([
      this.generateOption('conservative', prompts.conservative),
      this.generateOption('balanced', prompts.balanced),
      this.generateOption('bold', prompts.bold)
    ])
    
    return options
  }

  private buildCustomizationPrompts(
    analysis: RequestAnalysis,
    constraints: ValidationResult
  ): CustomizationPrompts {
    
    const baseContext = `
현재 템플릿: ${this.currentProject.templateBase.name}
수정 대상: ${analysis.target}
사용자 요청: ${analysis.userRequest}
기술적 제약: ${JSON.stringify(constraints.technicalLimits)}
디자인 제약: ${JSON.stringify(constraints.designLimits)}
`

    return {
      conservative: `
${baseContext}

보수적 접근법으로 수정해주세요:
- 기존 디자인 언어 유지
- 최소한의 변경으로 요구사항 충족
- 호환성과 안정성 우선
- 기존 사용자 경험 패턴 유지
      `,
      
      balanced: `
${baseContext}

균형적 접근법으로 수정해주세요:
- 적절한 수준의 혁신과 안정성
- 사용자 요구에 맞는 적극적 개선
- 현대적 디자인 트렌드 반영
- 사용성과 미적 가치의 균형
      `,
      
      bold: `
${baseContext}

대담한 접근법으로 수정해주세요:
- 창의적이고 혁신적인 디자인
- 최신 웹 기술과 트렜드 적극 활용
- 시각적 임팩트 극대화
- 독특하고 기억에 남는 경험 제공
      `
    }
  }
}
```

#### 🔗 컨텍스트 관리 시스템
```typescript
class ConversationContextManager {
  private contexts: Map<string, ConversationContext> = new Map()
  
  updateContext(
    sessionId: string, 
    step: ConversationStep
  ): ConversationContext {
    
    const context = this.contexts.get(sessionId) || this.createNewContext(sessionId)
    
    // 컨텍스트 업데이트
    context.steps.push(step)
    context.currentState = this.deriveStateFromSteps(context.steps)
    context.userPreferences = this.updatePreferences(context.userPreferences, step)
    context.constraintHistory = this.updateConstraints(context.constraintHistory, step)
    
    // 컨텍스트 압축 (메모리 효율성)
    if (context.steps.length > 20) {
      context = this.compressContext(context)
    }
    
    this.contexts.set(sessionId, context)
    return context
  }

  private deriveStateFromSteps(steps: ConversationStep[]): ProjectState {
    return steps.reduce((state, step) => {
      if (step.type === 'template:applied') {
        state.templateBase = step.data.template
      } else if (step.type === 'customization:applied') {
        state.currentCode = this.applyChanges(state.currentCode, step.data.changes)
      }
      return state
    }, this.getInitialState())
  }
}
```

### Week 5: 제약 조건 시스템 및 검증 로직

#### 🛡️ 제약 조건 엔진
```typescript
class ConstraintEngine {
  private rules: ConstraintRule[] = []
  
  async validateRequest(
    analysis: RequestAnalysis,
    project: ProjectState
  ): Promise<ValidationResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    
    // 기술적 제약 검증
    const technicalCheck = await this.checkTechnicalConstraints(analysis, project)
    violations.push(...technicalCheck.violations)
    warnings.push(...technicalCheck.warnings)
    
    // 디자인 제약 검증
    const designCheck = await this.checkDesignConstraints(analysis, project)
    violations.push(...designCheck.violations)
    warnings.push(...designCheck.warnings)
    
    // 비즈니스 제약 검증
    const businessCheck = await this.checkBusinessConstraints(analysis, project)
    violations.push(...businessCheck.violations)
    warnings.push(...businessCheck.warnings)
    
    return {
      isValid: violations.length === 0,
      violations,
      warnings,
      suggestions: this.generateSuggestions(violations, warnings),
      allowedAlternatives: this.findAlternatives(analysis, violations)
    }
  }

  private async checkTechnicalConstraints(
    analysis: RequestAnalysis,
    project: ProjectState
  ): Promise<ConstraintCheckResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    
    // 컴포넌트 호환성 검사
    if (analysis.targetComponent) {
      const component = project.templateBase.components.find(c => c.name === analysis.targetComponent)
      if (!component) {
        violations.push({
          type: 'component:not-found',
          message: `컴포넌트 '${analysis.targetComponent}'를 찾을 수 없습니다`,
          severity: 'error'
        })
      } else if (!component.customizable) {
        violations.push({
          type: 'component:not-customizable',
          message: `컴포넌트 '${analysis.targetComponent}'는 수정할 수 없습니다`,
          severity: 'error'
        })
      }
    }
    
    // 의존성 검사
    if (analysis.requiredFeatures) {
      for (const feature of analysis.requiredFeatures) {
        const dependency = this.checkFeatureDependency(feature, project)
        if (!dependency.available) {
          warnings.push({
            type: 'dependency:missing',
            message: `기능 '${feature}'를 위해 ${dependency.required.join(', ')}가 필요합니다`,
            severity: 'warning'
          })
        }
      }
    }
    
    return { violations, warnings }
  }

  private async checkDesignConstraints(
    analysis: RequestAnalysis,
    project: ProjectState
  ): Promise<ConstraintCheckResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    
    // 접근성 검사
    if (analysis.colorChanges) {
      const accessibilityCheck = await this.checkColorAccessibility(analysis.colorChanges)
      if (!accessibilityCheck.wcagCompliant) {
        warnings.push({
          type: 'accessibility:color-contrast',
          message: '색상 대비가 WCAG 기준을 충족하지 않을 수 있습니다',
          severity: 'warning'
        })
      }
    }
    
    // 반응형 디자인 검사
    if (analysis.layoutChanges) {
      const responsiveCheck = this.checkResponsiveCompatibility(analysis.layoutChanges)
      if (!responsiveCheck.compatible) {
        violations.push({
          type: 'responsive:incompatible',
          message: '요청하신 레이아웃은 모바일에서 적절히 표시되지 않을 수 있습니다',
          severity: 'error'
        })
      }
    }
    
    return { violations, warnings }
  }
}
```

## 🎭 Phase 3: 비교 및 선택 UI (2주)

### Week 6-7: 수정 전/후 비교 시스템

#### 🎯 주요 작업
- [ ] **실시간 미리보기 생성 시스템**
- [ ] **비교 WebView UI 구현**
- [ ] **선택지 인터랙션 UI/UX**

#### 🔄 실시간 미리보기 생성기
```typescript
class PreviewGenerator {
  private buildCache: Map<string, BuildResult> = new Map()
  private previewQueue: PreviewRequest[] = []
  
  async generateComparisonPreviews(
    options: CustomizationOption[],
    baseProject: ProjectState
  ): Promise<PreviewResult[]> {
    
    const previewPromises = options.map(async (option, index) => {
      const previewId = `preview-${Date.now()}-${index}`
      
      // 변경사항 적용
      const modifiedProject = await this.applyChanges(baseProject, option.changes)
      
      // 빌드 및 미리보기 생성
      const buildResult = await this.buildPreview(modifiedProject, previewId)
      
      // 스크린샷 생성
      const screenshot = await this.captureScreenshot(buildResult.previewUrl)
      
      return {
        optionId: option.id,
        previewId,
        previewUrl: buildResult.previewUrl,
        screenshot,
        buildTime: buildResult.duration,
        status: buildResult.status
      }
    })
    
    return Promise.all(previewPromises)
  }

  private async buildPreview(
    project: ProjectState,
    previewId: string
  ): Promise<BuildResult> {
    
    const cacheKey = this.generateCacheKey(project)
    const cached = this.buildCache.get(cacheKey)
    
    if (cached && this.isCacheValid(cached)) {
      return {
        ...cached,
        previewUrl: this.generatePreviewUrl(previewId)
      }
    }
    
    const startTime = Date.now()
    
    // 임시 빌드 디렉토리 생성
    const tempDir = await this.createTempDirectory(previewId)
    
    // 파일 생성
    await this.generateProjectFiles(project, tempDir)
    
    // 빌드 실행
    const buildResult = await this.buildManager.buildProject(tempDir, {
      mode: 'preview',
      optimization: false,
      sourcemap: false
    })
    
    const result = {
      previewUrl: this.deployPreview(buildResult, previewId),
      duration: Date.now() - startTime,
      status: buildResult.success ? 'success' : 'error',
      errors: buildResult.errors
    }
    
    // 캐시 저장
    this.buildCache.set(cacheKey, result)
    
    return result
  }

  private async captureScreenshot(previewUrl: string): Promise<string> {
    // 스크린샷 캡처 로직 (headless browser 사용)
    const screenshot = await this.screenshotService.capture(previewUrl, {
      width: 1200,
      height: 800,
      format: 'webp',
      quality: 80
    })
    
    return this.uploadScreenshot(screenshot)
  }
}
```

#### 🎨 비교 WebView UI 구현
```typescript
// 비교 WebView용 React 컴포넌트
const ComparisonViewer: React.FC<ComparisonViewerProps> = ({
  originalPreview,
  options,
  onSelect,
  onRegenerate
}) => {
  const [selectedOption, setSelectedOption] = useState<string | null>(null)
  const [viewMode, setViewMode] = useState<'grid' | 'split' | 'overlay'>('grid')
  
  return (
    <div className="comparison-viewer">
      <div className="comparison-header">
        <h2>커스터마이징 옵션 비교</h2>
        <div className="view-controls">
          <ViewModeToggle mode={viewMode} onChange={setViewMode} />
          <RegenerateButton onClick={onRegenerate} />
        </div>
      </div>
      
      <div className={`comparison-content ${viewMode}`}>
        {/* 원본 미리보기 */}
        <PreviewCard
          title="현재 버전"
          preview={originalPreview}
          isOriginal={true}
          className="original-preview"
        />
        
        {/* 옵션별 미리보기 */}
        {options.map((option) => (
          <PreviewCard
            key={option.id}
            title={option.description}
            preview={option.preview}
            intensity={option.intensity}
            reasoning={option.reasoning}
            isSelected={selectedOption === option.id}
            onClick={() => handleOptionSelect(option.id)}
            onPreview={() => handlePreviewHover(option.id)}
          />
        ))}
      </div>
      
      <div className="comparison-actions">
        <button 
          className="btn-primary"
          disabled={!selectedOption}
          onClick={() => selectedOption && onSelect(selectedOption)}
        >
          선택한 옵션 적용
        </button>
        <button 
          className="btn-secondary"
          onClick={() => onRegenerate()}
        >
          다른 옵션 생성
        </button>
      </div>
    </div>
  )
}

const PreviewCard: React.FC<PreviewCardProps> = ({
  title,
  preview,
  intensity,
  reasoning,
  isOriginal,
  isSelected,
  onClick,
  onPreview
}) => {
  return (
    <div 
      className={`preview-card ${intensity} ${isSelected ? 'selected' : ''}`}
      onClick={onClick}
      onMouseEnter={onPreview}
    >
      <div className="preview-header">
        <h3>{title}</h3>
        {intensity && (
          <IntensityBadge intensity={intensity} />
        )}
      </div>
      
      <div className="preview-image">
        <img 
          src={preview.screenshot} 
          alt={title}
          loading="lazy"
        />
        <div className="preview-overlay">
          <button className="preview-fullscreen">
            전체 화면으로 보기
          </button>
        </div>
      </div>
      
      {reasoning && (
        <div className="preview-reasoning">
          <h4>변경 이유</h4>
          <ul>
            {reasoning.map((reason, index) => (
              <li key={index}>{reason}</li>
            ))}
          </ul>
        </div>
      )}
      
      <div className="preview-metrics">
        <span>빌드 시간: {preview.buildTime}ms</span>
        <span>파일 크기: {preview.fileSize}KB</span>
      </div>
    </div>
  )
}

const IntensityBadge: React.FC<{ intensity: 'conservative' | 'balanced' | 'bold' }> = ({ intensity }) => {
  const labels = {
    conservative: '보수적',
    balanced: '균형적', 
    bold: '대담한'
  }
  
  const colors = {
    conservative: 'bg-green-100 text-green-800',
    balanced: 'bg-blue-100 text-blue-800',
    bold: 'bg-purple-100 text-purple-800'
  }
  
  return (
    <span className={`intensity-badge ${colors[intensity]}`}>
      {labels[intensity]}
    </span>
  )
}
```

#### 🎯 사용자 피드백 시스템
```typescript
class UserFeedbackCollector {
  private feedbackHistory: Map<string, UserFeedback[]> = new Map()
  
  async collectSelectionFeedback(
    sessionId: string,
    selection: OptionSelection
  ): Promise<void> {
    
    const feedback: UserFeedback = {
      sessionId,
      timestamp: Date.now(),
      type: 'option:selected',
      data: {
        selectedOptionId: selection.optionId,
        selectedIntensity: selection.intensity,
        rejectedOptions: selection.rejectedOptions,
        selectionTime: selection.selectionTime,
        reasoning: selection.userReasoning
      }
    }
    
    await this.storeFeedback(feedback)
    await this.updateUserProfile(sessionId, feedback)
  }

  async collectRegenerationFeedback(
    sessionId: string,
    regeneration: RegenerationRequest
  ): Promise<void> {
    
    const feedback: UserFeedback = {
      sessionId,
      timestamp: Date.now(),
      type: 'options:regenerated',
      data: {
        originalOptions: regeneration.originalOptions,
        regenerationReason: regeneration.reason,
        specificRequests: regeneration.additionalRequests
      }
    }
    
    await this.storeFeedback(feedback)
  }

  private async updateUserProfile(sessionId: string, feedback: UserFeedback): Promise<void> {
    const profile = await this.getUserProfile(sessionId)
    
    // 선호도 패턴 학습
    if (feedback.type === 'option:selected') {
      profile.preferredIntensity = this.updateIntensityPreference(
        profile.preferredIntensity,
        feedback.data.selectedIntensity
      )
      
      profile.designPreferences = this.updateDesignPreferences(
        profile.designPreferences,
        feedback.data
      )
    }
    
    await this.saveUserProfile(sessionId, profile)
  }
}
```

## 🚀 Phase 4: 최적화 및 고도화 (2주)

### Week 8: 성능 최적화

#### 🎯 주요 작업
- [ ] **빌드 캐싱 시스템 구현**
- [ ] **미리보기 최적화**
- [ ] **메모리 및 리소스 관리**

#### ⚡ 빌드 캐싱 시스템
```typescript
class BuildCacheManager {
  private cache: Map<string, CachedBuild> = new Map()
  private diskCache: DiskCacheManager
  private maxCacheSize = 100 // 최대 캐시 항목 수
  
  constructor() {
    this.diskCache = new DiskCacheManager('./cache/builds')
  }

  async getCachedBuild(cacheKey: string): Promise<CachedBuild | null> {
    // 메모리 캐시 확인
    const memoryCache = this.cache.get(cacheKey)
    if (memoryCache && this.isCacheValid(memoryCache)) {
      return memoryCache
    }
    
    // 디스크 캐시 확인
    const diskCache = await this.diskCache.get(cacheKey)
    if (diskCache && this.isCacheValid(diskCache)) {
      // 메모리 캐시에 복원
      this.cache.set(cacheKey, diskCache)
      return diskCache
    }
    
    return null
  }

  async setCachedBuild(cacheKey: string, build: BuildResult): Promise<void> {
    const cachedBuild: CachedBuild = {
      ...build,
      cacheKey,
      createdAt: Date.now(),
      accessCount: 0,
      lastAccessed: Date.now()
    }
    
    // 메모리 캐시 저장
    this.cache.set(cacheKey, cachedBuild)
    
    // 디스크 캐시 저장 (비동기)
    this.diskCache.set(cacheKey, cachedBuild).catch(err => 
      console.warn('Failed to save disk cache:', err)
    )
    
    // 캐시 크기 관리
    await this.manageCacheSize()
  }

  generateCacheKey(project: ProjectState, options?: BuildOptions): string {
    const projectHash = this.hashProject(project)
    const optionsHash = this.hashOptions(options)
    return `${projectHash}-${optionsHash}`
  }

  private hashProject(project: ProjectState): string {
    // 프로젝트 상태의 해시 생성 (파일 내용, 설정 등)
    const content = JSON.stringify({
      templateId: project.templateBase.id,
      files: this.hashFiles(project.currentCode),
      dependencies: project.dependencies,
      buildConfig: project.buildConfig
    })
    
    return this.createHash(content)
  }

  private async manageCacheSize(): Promise<void> {
    if (this.cache.size <= this.maxCacheSize) return
    
    // LRU 정책으로 캐시 정리
    const entries = Array.from(this.cache.entries())
      .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed)
    
    const toRemove = entries.slice(0, entries.length - this.maxCacheSize)
    
    for (const [key] of toRemove) {
      this.cache.delete(key)
      await this.diskCache.delete(key)
    }
  }
}
```

#### 🖼️ 미리보기 최적화
```typescript
class OptimizedPreviewGenerator extends PreviewGenerator {
  private screenshotQueue: Queue<ScreenshotTask> = new Queue()
  private previewPool: PreviewPool
  
  constructor() {
    super()
    this.previewPool = new PreviewPool({
      maxConcurrent: 3,
      timeout: 30000
    })
    
    // 스크린샷 워커 풀 시작
    this.startScreenshotWorkers()
  }

  async generateOptimizedPreviews(
    options: CustomizationOption[],
    baseProject: ProjectState
  ): Promise<PreviewResult[]> {
    
    // 1. 변경사항 분석으로 빌드 최적화
    const changeAnalysis = this.analyzeChanges(options, baseProject)
    
    // 2. 병렬 처리 가능한 작업과 순차 처리 작업 분리
    const { parallelTasks, sequentialTasks } = this.categorizeTasks(options, changeAnalysis)
    
    // 3. 병렬 처리
    const parallelResults = await Promise.all(
      parallelTasks.map(task => this.processPreviewTask(task))
    )
    
    // 4. 순차 처리 (의존성이 있는 작업들)
    const sequentialResults = []
    for (const task of sequentialTasks) {
      const result = await this.processPreviewTask(task)
      sequentialResults.push(result)
    }
    
    return [...parallelResults, ...sequentialResults]
  }

  private analyzeChanges(
    options: CustomizationOption[],
    baseProject: ProjectState
  ): ChangeAnalysis {
    
    return {
      affectedComponents: this.findAffectedComponents(options),
      styleChanges: this.extractStyleChanges(options),
      structuralChanges: this.extractStructuralChanges(options),
      assetChanges: this.extractAssetChanges(options),
      
      // 최적화 힌트
      canUseHotReload: this.canUseHotReload(options),
      canShareAssets: this.canShareAssets(options),
      canReuseLayout: this.canReuseLayout(options)
    }
  }

  private async processPreviewTask(task: PreviewTask): Promise<PreviewResult> {
    const instance = await this.previewPool.acquire()
    
    try {
      // 핫 리로드 가능한 경우 최적화된 빌드
      if (task.analysis.canUseHotReload) {
        return await this.generateHotReloadPreview(task, instance)
      }
      
      // 일반 빌드
      return await this.generateFullPreview(task, instance)
      
    } finally {
      this.previewPool.release(instance)
    }
  }

  private async generateHotReloadPreview(
    task: PreviewTask,
    instance: PreviewInstance
  ): Promise<PreviewResult> {
    
    // 기존 빌드 재사용하고 변경사항만 적용
    const baseUrl = await this.getBaseBuildUrl(task.baseProject)
    
    // CSS/JS 인젝션으로 변경사항 적용
    const modifications = await this.generateModifications(task.option.changes)
    
    const previewUrl = await instance.applyHotReload(baseUrl, modifications)
    
    // 가벼운 스크린샷 (뷰포트만)
    const screenshot = await this.captureViewportScreenshot(previewUrl)
    
    return {
      optionId: task.option.id,
      previewUrl,
      screenshot,
      buildTime: 50, // 핫 리로드는 매우 빠름
      status: 'success',
      optimized: true
    }
  }
}
```

### Week 9: 사용자 학습 기반 추천 개선 및 A/B 테스트

#### 🎯 주요 작업
- [ ] **사용자 행동 패턴 분석**
- [ ] **개인화된 추천 시스템**
- [ ] **A/B 테스트 프레임워크**
- [ ] **성능 분석 및 개선사항 도출**

#### 🧠 사용자 학습 시스템
```typescript
class UserLearningSystem {
  private behaviorAnalyzer: BehaviorAnalyzer
  private recommendationEngine: PersonalizedRecommendationEngine
  private abTestManager: ABTestManager
  
  constructor() {
    this.behaviorAnalyzer = new BehaviorAnalyzer()
    this.recommendationEngine = new PersonalizedRecommendationEngine()
    this.abTestManager = new ABTestManager()
  }

  async analyzeUserBehavior(userId: string): Promise<UserBehaviorProfile> {
    const rawData = await this.getUserInteractionData(userId)
    
    return {
      preferredIntensity: this.calculateIntensityPreference(rawData),
      designPatterns: this.identifyDesignPatterns(rawData),
      decisionSpeed: this.calculateDecisionSpeed(rawData),
      explorationTendency: this.calculateExplorationTendency(rawData),
      
      // 시간별 패턴
      timeBasedPreferences: this.analyzeTimePatterns(rawData),
      
      // 컨텍스트별 패턴
      contextualPreferences: this.analyzeContextualPatterns(rawData),
      
      // 만족도 패턴
      satisfactionIndicators: this.analyzeSatisfactionPatterns(rawData)
    }
  }

  private calculateIntensityPreference(data: UserInteractionData[]): IntensityPreference {
    const selections = data.filter(d => d.type === 'option:selected')
    const intensityCounts = {
      conservative: 0,
      balanced: 0,
      bold: 0
    }
    
    selections.forEach(selection => {
      intensityCounts[selection.data.intensity]++
    })
    
    const total = selections.length
    return {
      conservative: intensityCounts.conservative / total,
      balanced: intensityCounts.balanced / total,
      bold: intensityCounts.bold / total,
      
      // 신뢰도 (선택 횟수가 많을수록 높음)
      confidence: Math.min(total / 20, 1.0)
    }
  }

  private identifyDesignPatterns(data: UserInteractionData[]): DesignPattern[] {
    const patterns = []
    
    // 색상 선호도 패턴
    const colorChoices = this.extractColorChoices(data)
    if (colorChoices.length > 5) {
      patterns.push({
        type: 'color_preference',
        pattern: this.analyzeColorPreferences(colorChoices),
        confidence: 0.8
      })
    }
    
    // 레이아웃 선호도 패턴
    const layoutChoices = this.extractLayoutChoices(data)
    if (layoutChoices.length > 3) {
      patterns.push({
        type: 'layout_preference',
        pattern: this.analyzeLayoutPreferences(layoutChoices),
        confidence: 0.7
      })
    }
    
    // 타이포그래피 패턴
    const typographyChoices = this.extractTypographyChoices(data)
    if (typographyChoices.length > 3) {
      patterns.push({
        type: 'typography_preference',
        pattern: this.analyzeTypographyPreferences(typographyChoices),
        confidence: 0.6
      })
    }
    
    return patterns
  }
}
```

#### 🎯 개인화된 추천 엔진
```typescript
class PersonalizedRecommendationEngine extends TemplateRecommendationEngine {
  async generatePersonalizedRecommendations(
    query: string,
    userProfile: UserBehaviorProfile,
    context: RecommendationContext
  ): Promise<PersonalizedRecommendation[]> {
    
    // 1. 기본 추천 생성
    const baseRecommendations = await super.recommendTemplates(query)
    
    // 2. 사용자 프로필 기반 가중치 조정
    const personalizedScores = baseRecommendations.map(rec => ({
      ...rec,
      personalizedScore: this.calculatePersonalizedScore(rec, userProfile, context),
      personalizedReasons: this.generatePersonalizedReasons(rec, userProfile)
    }))
    
    // 3. A/B 테스트 적용
    const abTestVariant = await this.abTestManager.getVariant('recommendation_order', context.userId)
    const finalRecommendations = this.applyABTestVariant(personalizedScores, abTestVariant)
    
    return finalRecommendations
  }

  private calculatePersonalizedScore(
    recommendation: TemplateRecommendation,
    profile: UserBehaviorProfile,
    context: RecommendationContext
  ): number {
    
    let score = recommendation.confidence
    
    // 시간 기반 조정
    const timeBoost = this.getTimeBasedBoost(recommendation, profile.timeBasedPreferences, context.currentTime)
    score *= (1 + timeBoost * 0.1)
    
    // 설계 패턴 매칭
    const patternBoost = this.getPatternMatchBoost(recommendation, profile.designPatterns)
    score *= (1 + patternBoost * 0.15)
    
    // 강도 선호도 매칭
    const intensityBoost = this.getIntensityBoost(recommendation, profile.preferredIntensity)
    score *= (1 + intensityBoost * 0.1)
    
    // 탐험 vs 활용 균형
    const explorationBoost = this.getExplorationBoost(recommendation, profile.explorationTendency, context)
    score *= (1 + explorationBoost * 0.05)
    
    return Math.min(score, 1.0)
  }

  private generatePersonalizedReasons(
    recommendation: TemplateRecommendation,
    profile: UserBehaviorProfile
  ): string[] {
    
    const reasons = [...recommendation.reasons]
    
    // 개인화된 이유 추가
    if (profile.preferredIntensity.bold > 0.6) {
      reasons.push('대담한 디자인을 선호하시는 성향에 맞습니다')
    }
    
    const dominantPattern = profile.designPatterns
      .sort((a, b) => b.confidence - a.confidence)[0]
    
    if (dominantPattern && this.templateMatchesPattern(recommendation.template, dominantPattern)) {
      reasons.push(`자주 선택하시는 ${dominantPattern.type} 스타일과 일치합니다`)
    }
    
    return reasons
  }
}
```

#### 🧪 A/B 테스트 프레임워크
```typescript
class ABTestManager {
  private experiments: Map<string, ABExperiment> = new Map()
  private userAssignments: Map<string, Map<string, string>> = new Map()
  
  async createExperiment(experiment: ABExperiment): Promise<void> {
    this.experiments.set(experiment.id, experiment)
    await this.persistExperiment(experiment)
  }

  async getVariant(experimentId: string, userId: string): Promise<string> {
    const experiment = this.experiments.get(experimentId)
    if (!experiment || !experiment.active) {
      return 'control'
    }
    
    // 사용자별 일관된 배정
    let userExperiments = this.userAssignments.get(userId)
    if (!userExperiments) {
      userExperiments = new Map()
      this.userAssignments.set(userId, userExperiments)
    }
    
    let assignedVariant = userExperiments.get(experimentId)
    if (!assignedVariant) {
      assignedVariant = this.assignVariant(experiment, userId)
      userExperiments.set(experimentId, assignedVariant)
      await this.logAssignment(experimentId, userId, assignedVariant)
    }
    
    return assignedVariant
  }

  private assignVariant(experiment: ABExperiment, userId: string): string {
    // 사용자 ID 기반 해시로 일관된 배정
    const hash = this.hashUserId(userId + experiment.id)
    const random = (hash % 100) / 100
    
    let cumulative = 0
    for (const variant of experiment.variants) {
      cumulative += variant.trafficAllocation
      if (random < cumulative) {
        return variant.id
      }
    }
    
    return 'control'
  }

  async recordEvent(
    experimentId: string,
    userId: string,
    eventType: string,
    eventData: any
  ): Promise<void> {
    
    const variant = await this.getVariant(experimentId, userId)
    
    const event: ABTestEvent = {
      experimentId,
      userId,
      variant,
      eventType,
      eventData,
      timestamp: Date.now()
    }
    
    await this.persistEvent(event)
  }

  async getExperimentResults(experimentId: string): Promise<ExperimentResults> {
    const events = await this.getExperimentEvents(experimentId)
    const variants = this.experiments.get(experimentId)?.variants || []
    
    const results: ExperimentResults = {
      experimentId,
      totalUsers: new Set(events.map(e => e.userId)).size,
      variants: variants.map(variant => ({
        variantId: variant.id,
        users: new Set(events.filter(e => e.variant === variant.id).map(e => e.userId)).size,
        events: events.filter(e => e.variant === variant.id),
        metrics: this.calculateVariantMetrics(events.filter(e => e.variant === variant.id))
      })),
      statisticalSignificance: this.calculateSignificance(events, variants)
    }
    
    return results
  }
}

// A/B 테스트 실험 정의 예시
const recommendationOrderExperiment: ABExperiment = {
  id: 'recommendation_order',
  name: '추천 순서 최적화',
  description: '개인화 점수 vs 일반 점수 기반 추천 순서 비교',
  active: true,
  startDate: Date.now(),
  endDate: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30일
  
  variants: [
    {
      id: 'control',
      name: '기본 추천',
      trafficAllocation: 0.5,
      config: { usePersonalization: false }
    },
    {
      id: 'personalized',
      name: '개인화 추천',
      trafficAllocation: 0.5,
      config: { usePersonalization: true }
    }
  ],
  
  metrics: [
    { name: 'template_selection_rate', type: 'conversion' },
    { name: 'time_to_selection', type: 'duration' },
    { name: 'user_satisfaction', type: 'rating' }
  ]
}
```

#### 📊 성능 분석 및 개선사항 도출
```typescript
class PerformanceAnalyzer {
  async generateImplementationReport(): Promise<ImplementationReport> {
    const metrics = await this.collectMetrics()
    const userFeedback = await this.analyzeFeedback()
    const technicalMetrics = await this.analyzeTechnicalPerformance()
    
    return {
      summary: this.generateSummary(metrics, userFeedback, technicalMetrics),
      userExperience: {
        satisfactionScore: userFeedback.averageSatisfaction,
        completionRate: metrics.workflowCompletionRate,
        averageSessionDuration: metrics.averageSessionDuration,
        returnUserRate: metrics.returnUserRate
      },
      technicalPerformance: {
        averageBuildTime: technicalMetrics.averageBuildTime,
        cacheHitRate: technicalMetrics.cacheHitRate,
        errorRate: technicalMetrics.errorRate,
        systemUptime: technicalMetrics.uptime
      },
      aiPerformance: {
        intentAccuracy: metrics.intentRecognitionAccuracy,
        recommendationRelevance: metrics.recommendationRelevance,
        customizationSatisfaction: metrics.customizationSatisfaction
      },
      improvements: this.generateImprovementRecommendations(metrics, userFeedback, technicalMetrics)
    }
  }

  private generateImprovementRecommendations(
    metrics: SystemMetrics,
    feedback: UserFeedback,
    technical: TechnicalMetrics
  ): ImprovementRecommendation[] {
    
    const recommendations = []
    
    // 성능 개선
    if (technical.averageBuildTime > 5000) {
      recommendations.push({
        category: 'performance',
        priority: 'high',
        title: '빌드 시간 최적화',
        description: '평균 빌드 시간이 5초를 초과합니다',
        actions: [
          '증분 빌드 시스템 도입',
          '병렬 처리 최적화',
          '불필요한 dependency 제거'
        ]
      })
    }
    
    // 사용자 경험 개선
    if (feedback.averageSatisfaction < 4.0) {
      recommendations.push({
        category: 'ux',
        priority: 'medium',
        title: '사용자 만족도 개선',
        description: '사용자 만족도가 목표치(4.5)보다 낮습니다',
        actions: [
          'UI/UX 개선',
          '더 정확한 AI 추천',
          '사용자 온보딩 개선'
        ]
      })
    }
    
    // AI 정확도 개선
    if (metrics.intentRecognitionAccuracy < 0.85) {
      recommendations.push({
        category: 'ai',
        priority: 'high',
        title: 'AI 의도 파악 정확도 개선',
        description: '의도 파악 정확도가 목표치(85%)보다 낮습니다',
        actions: [
          '프롬프트 엔지니어링 개선',
          '더 많은 학습 데이터 수집',
          '컨텍스트 이해 알고리즘 개선'
        ]
      })
    }
    
    return recommendations
  }
}
```

## 📈 성공 지표 (KPIs)

### 📊 Phase별 성공 지표

#### Phase 1: 템플릿 시스템
- **완료율**: 모든 기본 템플릿 5개 제작 완료
- **품질**: 각 템플릿의 반응형 디자인 호환성 100%
- **성능**: 템플릿 로딩 시간 < 2초

#### Phase 2: 대화형 커스터마이징
- **정확도**: AI 의도 파악 정확도 > 80%
- **만족도**: 생성된 옵션에 대한 사용자 만족도 > 4.0/5.0
- **완성도**: 제약 조건 위반율 < 5%

#### Phase 3: 비교 및 선택 UI
- **사용성**: 옵션 선택 완료율 > 90%
- **성능**: 미리보기 생성 시간 < 10초
- **만족도**: UI/UX 만족도 > 4.2/5.0

#### Phase 4: 최적화 및 고도화
- **성능**: 빌드 캐시 히트율 > 60%
- **개인화**: 개인화 추천 정확도 > 85%
- **안정성**: 시스템 업타임 > 99.5%

## 🔧 기술 스택 및 도구

### 🏗️ 핵심 기술 스택
- **Frontend**: React 18+ TypeScript, Tailwind CSS
- **Backend**: Node.js, Express, TypeScript
- **AI/ML**: OpenAI GPT-4, LangChain, Custom Prompt Engineering
- **빌드 시스템**: Webpack 5, Vite (개발환경)
- **캐싱**: Redis, File System Cache
- **데이터베이스**: PostgreSQL (사용자 데이터), SQLite (캐시)

### 🛠️ 개발 도구
- **개발환경**: VS Code, WindWalker Extension
- **테스팅**: Jest, Playwright, Storybook
- **모니터링**: Winston (로깅), Prometheus (메트릭)
- **배포**: Docker, GitHub Actions

## 🚀 배포 및 롤아웃 계획

### 📅 배포 일정
- **Week 1-2**: Phase 1 개발 및 내부 테스트
- **Week 3-5**: Phase 2 개발 및 알파 테스트 (내부 사용자)
- **Week 6-7**: Phase 3 개발 및 베타 테스트 (제한된 외부 사용자)
- **Week 8-9**: Phase 4 개발 및 프로덕션 준비
- **Week 10**: 공식 릴리스

### 🎯 롤아웃 전략
1. **내부 테스트** (Week 1-5): 개발팀 및 QA팀 테스트
2. **클로즈 베타** (Week 6-7): 선별된 파워 유저 50명
3. **오픈 베타** (Week 8-9): 일반 사용자 500명 제한
4. **단계적 릴리스** (Week 10): 전체 사용자 대상 순차 배포

이 구현 계획을 통해 WindWalker는 시장에서 차별화된 AI 대화식 웹사이트 빌더로 자리잡을 수 있을 것입니다. 각 Phase별로 철저한 테스트와 사용자 피드백을 수집하여 지속적으로 개선해나가겠습니다.