# 15. AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë” êµ¬í˜„ ê³„íš

## ğŸ“‹ êµ¬í˜„ ê°œìš”

ì´ ë¬¸ì„œëŠ” WindWalkerì˜ ê¸°ì¡´ MessageBridge ì•„í‚¤í…ì²˜ì— AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë”ë¥¼ í†µí•©í•˜ëŠ” **10ì£¼ê°„ì˜ êµ¬ì²´ì ì¸ êµ¬í˜„ ê³„íš**ì„ ì œì‹œí•©ë‹ˆë‹¤. 14ë²ˆ ì„¤ê³„ ë¬¸ì„œë¥¼ ë°”íƒ•ìœ¼ë¡œ **ì ì§„ì ì´ê³  ì•ˆì „í•œ êµ¬í˜„ ë°©ì‹**ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.

### ğŸ¯ í•µì‹¬ êµ¬í˜„ ì „ëµ
- **ê¸°ì¡´ ì‹œìŠ¤í…œ ë¬´ì¤‘ë‹¨**: Phase 1-5 ê¸°ëŠ¥ 100% ìœ ì§€í•˜ë©° í™•ì¥
- **ë¼ìš°íŒ… ê¸°ë°˜ í†µí•©**: MessageBridge ë¼ìš°íŒ…ìœ¼ë¡œ ìƒˆ ê¸°ëŠ¥ ì¶”ê°€
- **ì ì§„ì  ë°°í¬**: ì£¼ì°¨ë³„ ê¸°ëŠ¥ ì™„ì„± í›„ ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ ë° ê²€ì¦
- **ì•ˆì „ì¥ì¹˜ êµ¬ì¶•**: Feature Flagë¡œ ì–¸ì œë“  ë¡¤ë°± ê°€ëŠ¥

---

## ğŸ“… ì „ì²´ êµ¬í˜„ ì¼ì •

```mermaid
gantt
    title WindWalker AI ëŒ€í™”ì‹ ë¹Œë” êµ¬í˜„ ì¼ì •
    dateFormat  YYYY-MM-DD
    section Phase 1
    ê¸°ë°˜ êµ¬ì¡° ì„¤ì •           :p1, 2025-08-05, 7d
    MessageBridge í™•ì¥       :p2, after p1, 7d
    section Phase 2  
    í…œí”Œë¦¿ ì‹œìŠ¤í…œ           :p3, after p2, 10d
    AI ì˜ë„ ë¶„ì„           :p4, after p3, 4d
    section Phase 3
    ì»¤ìŠ¤í„°ë§ˆì´ì§• ì—”ì§„        :p5, after p4, 14d
    ì œì•½ì¡°ê±´ ì‹œìŠ¤í…œ         :p6, after p5, 7d
    section Phase 4
    ë¹„êµ UI ì‹œìŠ¤í…œ          :p7, after p6, 10d
    ë¯¸ë¦¬ë³´ê¸° ìƒì„±ê¸°         :p8, after p7, 4d
    section Phase 5
    ì„±ëŠ¥ ìµœì í™”            :p9, after p8, 7d
    ë°°í¬ ì¤€ë¹„              :p10, after p9, 7d
```

| Phase | ê¸°ê°„ | ì£¼ìš” ì‘ì—… | ì™„ë£Œ ê¸°ì¤€ |
|-------|------|-----------|-----------|
| **Phase 1** | 2ì£¼ | ê¸°ë°˜ êµ¬ì¡° ë° MessageBridge í™•ì¥ | ìƒˆ ë¼ìš°íŒ… ì‹œìŠ¤í…œ ë™ì‘ |
| **Phase 2** | 2ì£¼ | í…œí”Œë¦¿ ì‹œìŠ¤í…œ ë° AI ì˜ë„ ë¶„ì„ | 5ê°œ í…œí”Œë¦¿ ì¶”ì²œ ì„±ê³µ |
| **Phase 3** | 3ì£¼ | ì»¤ìŠ¤í„°ë§ˆì´ì§• ì—”ì§„ ë° ì œì•½ì¡°ê±´ | 3ê°€ì§€ ì˜µì…˜ ìƒì„± ì„±ê³µ |
| **Phase 4** | 2ì£¼ | ë¹„êµ UI ë° ë¯¸ë¦¬ë³´ê¸° ì‹œìŠ¤í…œ | ì‹¤ì‹œê°„ ë¹„êµ ë·° ì™„ì„± |
| **Phase 5** | 1ì£¼ | ì„±ëŠ¥ ìµœì í™” ë° ë°°í¬ ì¤€ë¹„ | í”„ë¡œë•ì…˜ í™˜ê²½ ê²€ì¦ |

---

## ğŸš€ Phase 1: ê¸°ë°˜ êµ¬ì¡° ì„¤ì • (2ì£¼)

### Week 1: MessageBridge í™•ì¥ ë° ë¼ìš°íŒ… ì‹œìŠ¤í…œ

#### ğŸ¯ ëª©í‘œ
ê¸°ì¡´ MessageBridgeë¥¼ í™•ì¥í•˜ì—¬ AI ì›Œí¬í”Œë¡œìš° ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ë¼ìš°íŒ… ì‹œìŠ¤í…œ êµ¬ì¶•

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 1-2: MessageBridge í™•ì¥ ì„¤ê³„
```typescript
// 1. ê¸°ì¡´ MessageBridge í´ë˜ìŠ¤ í™•ì¥
class EnhancedMessageBridge extends MessageBridge {
  // ìƒˆë¡œìš´ ì˜ì¡´ì„± ì¶”ê°€
  private aiWorkflowRouter: AIWorkflowRouter
  private serviceRegistry: ServiceRegistry
  private featureFlags: FeatureFlagManager
  
  constructor(
    // ê¸°ì¡´ ì˜ì¡´ì„±ë“¤
    fileManager: FileManager,
    buildManager: BuildManager,
    llmService: LLMService,
    codeGenerationService: CodeGenerationService,
    // ìƒˆë¡œìš´ ì˜ì¡´ì„±ë“¤
    aiWorkflowRouter: AIWorkflowRouter,
    serviceRegistry: ServiceRegistry
  ) {
    super(fileManager, buildManager, llmService, codeGenerationService)
    this.aiWorkflowRouter = aiWorkflowRouter
    this.serviceRegistry = serviceRegistry
    this.featureFlags = new FeatureFlagManager()
  }
}
```

##### Day 3-4: ë¼ìš°íŒ… ì‹œìŠ¤í…œ êµ¬í˜„
```typescript
// 2. ë©”ì‹œì§€ íƒ€ì… í™•ì¥ (Git + IndexedDB ì§€ì› í¬í•¨)
interface AIWorkflowMessage extends Message {
  workflowType: 'template' | 'customization' | 'comparison'
  sessionId: string
  conversationContext?: ConversationContext
  gitCommitRef?: string  // Git ì»¤ë°‹ ì¶”ì ìš©
  persistToHistory?: boolean  // ëŒ€í™” íˆìŠ¤í† ë¦¬ ì €ì¥ ì—¬ë¶€
}

// 3. ë¼ìš°íŒ… ë¡œì§ êµ¬í˜„ (Git + ëŒ€í™” ì €ì¥ í†µí•©)
async processMessage(message: UnifiedMessage, source: MessageSource): Promise<void> {
  // Feature Flag í™•ì¸
  if (!this.featureFlags.isEnabled('ai_workflow')) {
    return await super.processMessage(message, source)
  }
  
  // Git ìƒíƒœ ì²´í¬ ë° ì»¤ë°‹ ìƒì„±
  if (message.workflowType) {
    const gitManager = this.serviceRegistry.getService<GitManager>('gitManager')
    const currentCommit = await gitManager.getCurrentCommit()
    message.gitCommitRef = currentCommit.hash
  }
  
  // ë©”ì‹œì§€ íƒ€ì…ë³„ ë¼ìš°íŒ…
  if (this.isAIWorkflowMessage(message)) {
    return await this.handleAIWorkflowMessage(message, source)
  }
  
  // ê¸°ì¡´ ë©”ì‹œì§€ëŠ” ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬
  return await super.processMessage(message, source)
}
```

##### Day 5-7: Git í†µí•© ì‹œìŠ¤í…œ êµ¬í˜„
```typescript
// 4. Git ë²„ì „ ê´€ë¦¬ í†µí•©
class GitVersionManager {
  private gitRepo: SimpleGit
  
  constructor(private workspacePath: string) {
    this.gitRepo = simpleGit(workspacePath)
  }
  
  // AI ëŒ€í™” ë‹¨ìœ„ë³„ ì»¤ë°‹ ìƒì„±
  async createConversationCommit(
    conversationId: string, 
    message: string,
    files: string[]
  ): Promise<GitCommitInfo> {
    const commitMessage = `[AI-Chat-${conversationId}] ${message}`
    
    // ë³€ê²½ëœ íŒŒì¼ë“¤ ìŠ¤í…Œì´ì§•
    await this.gitRepo.add(files)
    
    // ì»¤ë°‹ ìƒì„± (ë©”íƒ€ë°ì´í„° í¬í•¨)
    const commit = await this.gitRepo.commit(commitMessage, files, {
      '--author': 'WindWalker AI <ai@windwalker.dev>',
      '--trailer': `Conversation-ID: ${conversationId}`,
      '--trailer': `Generated-By: AI-Workflow-Engine`
    })
    
    return {
      hash: commit.commit,
      message: commitMessage,
      conversationId,
      timestamp: new Date(),
      files
    }
  }
  
  // íŠ¹ì • ëŒ€í™”ë¡œ ë˜ëŒë¦¬ê¸°
  async revertToConversation(conversationId: string): Promise<void> {
    // ëŒ€í™” IDë¡œ ì»¤ë°‹ ê²€ìƒ‰
    const commits = await this.gitRepo.log({
      '--grep': `Conversation-ID: ${conversationId}`
    })
    
    if (commits.latest) {
      await this.gitRepo.reset(['--hard', commits.latest.hash])
      console.log(`âœ… ëŒ€í™” ${conversationId} ìƒíƒœë¡œ ë³µêµ¬ ì™„ë£Œ`)
    }
  }
  
  // ëŒ€í™” íˆìŠ¤í† ë¦¬ ê¸°ë°˜ íŒ¨í„´ ì¶”ì¶œ
  async extractConversationPatterns(): Promise<ConversationPattern[]> {
    const logs = await this.gitRepo.log({
      '--grep': 'AI-Chat-',
      '--pretty': 'format:%H|%s|%b'
    })
    
    return logs.all.map(log => ({
      commitHash: log.hash,
      conversationId: this.extractConversationId(log.message),
      message: log.message,
      timestamp: log.date,
      fileChanges: this.parseFileChanges(log)
    }))
  }
}

// 5. ServiceRegistry êµ¬í˜„ (Git ë§¤ë‹ˆì € í¬í•¨)
class ServiceRegistry {
  private services: Map<string, WindWalkerService> = new Map()
  private messageRoutes: Map<string, string> = new Map()
  
  async registerService(service: WindWalkerService): Promise<void> {
    await service.initialize()
    this.services.set(service.serviceName, service)
    
    for (const messageType of service.messageTypes) {
      this.messageRoutes.set(messageType, service.serviceName)
    }
  }
  
  getService<T extends WindWalkerService>(serviceName: string): T {
    return this.services.get(serviceName) as T
  }
}

// 6. Feature Flag ë§¤ë‹ˆì €
class FeatureFlagManager {
  private flags: Map<string, boolean> = new Map([
    ['ai_workflow', false],
    ['template_recommendation', false],
    ['conversational_customization', false],
    ['comparison_generation', false],
    ['git_integration', false],  // Git í†µí•© ê¸°ëŠ¥
    ['conversation_persistence', false]  // ëŒ€í™” ì €ì¥ ê¸°ëŠ¥
  ])
  
  isEnabled(flagName: string): boolean {
    return this.flags.get(flagName) || false
  }
  
  enable(flagName: string): void {
    this.flags.set(flagName, true)
    console.log(`Feature enabled: ${flagName}`)
  }
}
```

#### âœ… Week 1 ì™„ë£Œ ê¸°ì¤€
- [ ] EnhancedMessageBridge í´ë˜ìŠ¤ êµ¬í˜„ ì™„ë£Œ
- [ ] AI ì›Œí¬í”Œë¡œìš° ë©”ì‹œì§€ ë¼ìš°íŒ… ë™ì‘ í™•ì¸
- [ ] Feature Flag ì‹œìŠ¤í…œìœ¼ë¡œ ì•ˆì „í•œ í™œì„±í™”/ë¹„í™œì„±í™” ê°€ëŠ¥
- [ ] ê¸°ì¡´ Phase 1-5 ê¸°ëŠ¥ 100% ì •ìƒ ë™ì‘

### Week 2: AI ì›Œí¬í”Œë¡œìš° ë¼ìš°í„° ë° ê¸°ë³¸ ì„œë¹„ìŠ¤

#### ğŸ¯ ëª©í‘œ
AI ì›Œí¬í”Œë¡œìš° ë¼ìš°í„° êµ¬í˜„ ë° ê¸°ë³¸ ì„œë¹„ìŠ¤ë“¤ (TemplateManager, ContextManager) ê³¨ê²© êµ¬í˜„

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 8-10: AIWorkflowRouter êµ¬í˜„
```typescript
// 1. ì›Œí¬í”Œë¡œìš° ë¼ìš°í„° ì¸í„°í˜ì´ìŠ¤
interface AIWorkflowRouter {
  routeWorkflow(message: AIWorkflowMessage): Promise<WorkflowResult>
  registerHandler(type: string, handler: WorkflowHandler): void
}

// 2. êµ¬ì²´ì  êµ¬í˜„
class ConversationalWorkflowRouter implements AIWorkflowRouter {
  private handlers: Map<string, WorkflowHandler> = new Map()
  
  constructor(
    private templateManager: TemplateManager,
    private contextManager: AIContextManager
  ) {
    this.registerDefaultHandlers()
  }
  
  private registerDefaultHandlers(): void {
    // í…œí”Œë¦¿ ê´€ë ¨ í•¸ë“¤ëŸ¬
    this.handlers.set('template:search', new TemplateSearchHandler(this.templateManager))
    this.handlers.set('template:recommend', new TemplateRecommendHandler(this.templateManager))
    
    // ì»¨í…ìŠ¤íŠ¸ ê´€ë ¨ í•¸ë“¤ëŸ¬
    this.handlers.set('context:update', new ContextUpdateHandler(this.contextManager))
  }
  
  async routeWorkflow(message: AIWorkflowMessage): Promise<WorkflowResult> {
    const handler = this.handlers.get(message.type)
    if (!handler) {
      throw new Error(`No handler for workflow type: ${message.type}`)
    }
    
    // ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ
    const context = await this.contextManager.getContext(message.sessionId)
    
    // ì›Œí¬í”Œë¡œìš° ì‹¤í–‰
    const result = await handler.handle(message, context)
    
    // ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
    await this.contextManager.updateContext(message.sessionId, result.updatedContext)
    
    return result
  }
}
```

##### Day 11-12: ê¸°ë³¸ ì„œë¹„ìŠ¤ ê³¨ê²© êµ¬í˜„
```typescript
// 3. TemplateManager ê³¨ê²©
class TemplateManager {
  private templates: Map<string, TemplateMetadata> = new Map()
  
  constructor() {
    this.loadBasicTemplates()
  }
  
  private loadBasicTemplates(): void {
    // ê¸°ë³¸ í…œí”Œë¦¿ 5ê°œ ë©”íƒ€ë°ì´í„°ë§Œ ë¡œë“œ (ì‹¤ì œ íŒŒì¼ì€ Phase 2ì—ì„œ)
    const basicTemplates = [
      { id: 'blog-modern', name: 'Modern Blog', category: 'blog' },
      { id: 'ecommerce-pro', name: 'E-commerce Pro', category: 'ecommerce' },
      { id: 'portfolio-creative', name: 'Creative Portfolio', category: 'portfolio' },
      { id: 'cafe-cozy', name: 'Cozy Cafe', category: 'restaurant' },
      { id: 'corporate-clean', name: 'Corporate Clean', category: 'corporate' }
    ]
    
    basicTemplates.forEach(template => {
      this.templates.set(template.id, template as TemplateMetadata)
    })
  }
  
  async searchTemplates(query: string): Promise<TemplateMetadata[]> {
    // ê¸°ë³¸ ê²€ìƒ‰ ë¡œì§ (Phase 2ì—ì„œ AI ê¸°ë°˜ìœ¼ë¡œ í™•ì¥)
    const results = Array.from(this.templates.values())
      .filter(template => 
        template.name.toLowerCase().includes(query.toLowerCase()) ||
        template.category.toLowerCase().includes(query.toLowerCase())
      )
    
    return results.slice(0, 3)
  }
}

// 4. AIContextManager ê³¨ê²©
class AIContextManager {
  private contexts: Map<string, ConversationContext> = new Map()
  
  async getContext(sessionId: string): Promise<ConversationContext> {
    let context = this.contexts.get(sessionId)
    
    if (!context) {
      context = this.createNewContext(sessionId)
      this.contexts.set(sessionId, context)
    }
    
    return context
  }
  
  async updateContext(
    sessionId: string, 
    updates: Partial<ConversationContext>
  ): Promise<ConversationContext> {
    const context = await this.getContext(sessionId)
    const updatedContext = { ...context, ...updates, lastUpdated: Date.now() }
    this.contexts.set(sessionId, updatedContext)
    return updatedContext
  }
  
  private createNewContext(sessionId: string): ConversationContext {
    return {
      sessionId,
      startedAt: Date.now(),
      lastUpdated: Date.now(),
      conversationHistory: [],
      userPreferences: {},
      userBehaviorProfile: this.createDefaultProfile()
    }
  }
}
```

##### Day 13-14: ì›Œí¬í”Œë¡œìš° í•¸ë“¤ëŸ¬ ê¸°ë³¸ êµ¬í˜„
```typescript
// 5. ì›Œí¬í”Œë¡œìš° í•¸ë“¤ëŸ¬ ê¸°ë³¸ í´ë˜ìŠ¤
abstract class WorkflowHandler {
  abstract handle(message: AIWorkflowMessage, context: ConversationContext): Promise<WorkflowResult>
}

// 6. í…œí”Œë¦¿ ê²€ìƒ‰ í•¸ë“¤ëŸ¬
class TemplateSearchHandler extends WorkflowHandler {
  constructor(private templateManager: TemplateManager) {
    super()
  }
  
  async handle(
    message: TemplateSearchMessage, 
    context: ConversationContext
  ): Promise<WorkflowResult> {
    
    const templates = await this.templateManager.searchTemplates(message.query)
    
    return {
      type: 'template:search:result',
      data: {
        query: message.query,
        results: templates,
        totalFound: templates.length
      },
      updatedContext: {
        ...context,
        searchHistory: [...(context.searchHistory || []), message.query]
      }
    }
  }
}

// 7. í…œí”Œë¦¿ ì¶”ì²œ í•¸ë“¤ëŸ¬ (ê¸°ë³¸ ë²„ì „)
class TemplateRecommendHandler extends WorkflowHandler {
  constructor(private templateManager: TemplateManager) {
    super()
  }
  
  async handle(
    message: TemplateRecommendMessage, 
    context: ConversationContext
  ): Promise<WorkflowResult> {
    
    // Phase 1ì—ì„œëŠ” ë‹¨ìˆœ ì¶”ì²œ (Phase 2ì—ì„œ AI ê¸°ë°˜ìœ¼ë¡œ í™•ì¥)
    const allTemplates = await this.templateManager.getAllTemplates()
    const recommendations = allTemplates.slice(0, 3)
    
    return {
      type: 'template:recommend:result',
      data: {
        recommendations: recommendations.map(template => ({
          template,
          confidence: 0.8, // ì„ì‹œ ê°’
          reasons: ['ê¸°ë³¸ ì¶”ì²œ'] // ì„ì‹œ ê°’
        }))
      },
      updatedContext: context
    }
  }
}
```

#### âœ… Week 2 ì™„ë£Œ ê¸°ì¤€
- [ ] AIWorkflowRouter ê¸°ë³¸ ë™ì‘ í™•ì¸
- [ ] TemplateManager ê¸°ë³¸ ê²€ìƒ‰ ê¸°ëŠ¥ ë™ì‘
- [ ] AIContextManager ì»¨í…ìŠ¤íŠ¸ ì €ì¥/ë¡œë“œ ë™ì‘
- [ ] ì›Œí¬í”Œë¡œìš° í•¸ë“¤ëŸ¬ 2ê°œ ì´ìƒ ë™ì‘ í™•ì¸
- [ ] ì „ì²´ ì‹œìŠ¤í…œ í†µí•© í…ŒìŠ¤íŠ¸ í†µê³¼

---

## ğŸ¨ Phase 2: í…œí”Œë¦¿ ì‹œìŠ¤í…œ ë° AI ì˜ë„ ë¶„ì„ (2ì£¼)

### Week 3: í…œí”Œë¦¿ ì‹œìŠ¤í…œ êµ¬í˜„

#### ğŸ¯ ëª©í‘œ
5ê°œ ê¸°ë³¸ í…œí”Œë¦¿ ì œì‘ ë° ë©”íƒ€ë°ì´í„° ì‹œìŠ¤í…œ, í…œí”Œë¦¿ ë¡œë”© ë° ê´€ë¦¬ ì‹œìŠ¤í…œ ì™„ì„±

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 15-16: í…œí”Œë¦¿ ë©”íƒ€ë°ì´í„° êµ¬ì¡° ì™„ì„±
```typescript
// 1. ì™„ì „í•œ í…œí”Œë¦¿ ë©”íƒ€ë°ì´í„° êµ¬ì¡°
interface TemplateMetadata {
  id: string
  name: string
  category: 'blog' | 'ecommerce' | 'portfolio' | 'restaurant' | 'corporate'
  description: string
  tags: string[]
  
  // AI ì›Œí¬í”Œë¡œìš° ì§€ì›
  aiCapabilities: {
    customizationPoints: CustomizationPoint[]
    supportedWorkflows: WorkflowType[]
    intelligentDefaults: Record<string, any>
  }
  
  // íŒŒì¼ êµ¬ì¡°
  files: {
    html: string[]
    css: string[]
    js: string[]
    assets: string[]
  }
  
  // ë¯¸ë¦¬ë³´ê¸° ì •ë³´
  previewImages: {
    desktop: string
    tablet: string
    mobile: string
  }
  
  // ë¹„ì¦ˆë‹ˆìŠ¤ ì •ë³´
  industry: string[]
  targetAudience: string[]
  keyFeatures: string[]
}

// 2. ì»¤ìŠ¤í„°ë§ˆì´ì§• í¬ì¸íŠ¸ ì •ì˜
interface CustomizationPoint {
  id: string
  name: string
  type: 'color' | 'layout' | 'content' | 'typography' | 'component'
  description: string
  
  // AI ì§€ì› ì •ë³´
  aiPromptHints: string[]
  constraintRules: ConstraintRule[]
  
  // ê¸°ìˆ ì  ë§¤í•‘
  cssSelectors: string[]
  componentProps: string[]
  affectedFiles: string[]
}
```

##### Day 17-19: ê¸°ë³¸ í…œí”Œë¦¿ 5ê°œ ì œì‘
```typescript
// 3. ë¸”ë¡œê·¸ í…œí”Œë¦¿ ìƒì„¸ êµ¬í˜„
const blogTemplate: TemplateMetadata = {
  id: 'blog-modern-001',
  name: 'Modern Blog',
  category: 'blog',
  description: 'ê¹”ë”í•˜ê³  ì½ê¸° ì‰¬ìš´ í˜„ëŒ€ì  ë¸”ë¡œê·¸ í…œí”Œë¦¿',
  tags: ['responsive', 'seo-friendly', 'dark-mode'],
  
  aiCapabilities: {
    customizationPoints: [
      {
        id: 'header-style',
        name: 'í—¤ë” ìŠ¤íƒ€ì¼',
        type: 'layout',
        description: 'í—¤ë” ë ˆì´ì•„ì›ƒê³¼ ë„¤ë¹„ê²Œì´ì…˜ ìŠ¤íƒ€ì¼',
        aiPromptHints: ['ë„¤ë¹„ê²Œì´ì…˜', 'ë¡œê³  ìœ„ì¹˜', 'ë©”ë‰´ ìŠ¤íƒ€ì¼'],
        constraintRules: [
          { type: 'layout', allowed: ['centered', 'left-aligned', 'split'] },
          { type: 'menu-items', max: 7 }
        ],
        cssSelectors: ['.header', '.navigation', '.logo'],
        componentProps: ['headerStyle', 'navigationLayout'],
        affectedFiles: ['index.html', 'style.css']
      },
      {
        id: 'color-scheme',
        name: 'ì»¬ëŸ¬ ìŠ¤í‚´',
        type: 'color',
        description: 'ì „ì²´ ì‚¬ì´íŠ¸ ìƒ‰ìƒ í…Œë§ˆ',
        aiPromptHints: ['ë¸Œëœë“œ ì»¬ëŸ¬', 'ë‹¤í¬ëª¨ë“œ', 'accent ì»¬ëŸ¬'],
        constraintRules: [
          { type: 'contrast', min: 4.5 }, // WCAG AA
          { type: 'color-count', max: 5 }
        ],
        cssSelectors: [':root', '.theme-colors'],
        componentProps: ['primaryColor', 'secondaryColor'],
        affectedFiles: ['style.css', 'theme.css']
      }
    ],
    supportedWorkflows: ['template', 'customization', 'comparison'],
    intelligentDefaults: {
      primaryColor: '#2563eb',
      headerStyle: 'centered',
      postLayout: 'grid'
    }
  },
  
  files: {
    html: ['index.html', 'post.html', 'about.html'],
    css: ['style.css', 'theme.css', 'responsive.css'],
    js: ['main.js', 'theme-toggle.js'],
    assets: ['hero-bg.jpg', 'author-avatar.jpg']
  },
  
  previewImages: {
    desktop: '/templates/blog-modern/preview-desktop.jpg',
    tablet: '/templates/blog-modern/preview-tablet.jpg',
    mobile: '/templates/blog-modern/preview-mobile.jpg'
  },
  
  industry: ['media', 'personal', 'education'],
  targetAudience: ['writers', 'journalists', 'educators'],
  keyFeatures: ['SEO ìµœì í™”', 'ë‹¤í¬ëª¨ë“œ', 'ë°˜ì‘í˜•', 'ì†Œì…œ ê³µìœ ']
}
```

##### Day 20-21: í…œí”Œë¦¿ íŒŒì¼ ì‹œìŠ¤í…œ êµ¬í˜„
```typescript
// 4. í…œí”Œë¦¿ íŒŒì¼ ë§¤ë‹ˆì €
class TemplateFileManager {
  private readonly templatesBasePath = 'workspace/templates'
  
  async loadTemplateFiles(templateId: string): Promise<TemplateFiles> {
    const metadata = await this.getTemplateMetadata(templateId)
    const files: TemplateFiles = {}
    
    // HTML íŒŒì¼ ë¡œë“œ
    for (const htmlFile of metadata.files.html) {
      const content = await this.readFile(`${this.templatesBasePath}/${templateId}/${htmlFile}`)
      files[htmlFile] = content
    }
    
    // CSS íŒŒì¼ ë¡œë“œ
    for (const cssFile of metadata.files.css) {
      const content = await this.readFile(`${this.templatesBasePath}/${templateId}/${cssFile}`)
      files[cssFile] = content
    }
    
    // JS íŒŒì¼ ë¡œë“œ
    for (const jsFile of metadata.files.js) {
      const content = await this.readFile(`${this.templatesBasePath}/${templateId}/${jsFile}`)
      files[jsFile] = content
    }
    
    return files
  }
  
  async applyTemplateToProject(
    templateId: string, 
    projectPath: string
  ): Promise<void> {
    
    const templateFiles = await this.loadTemplateFiles(templateId)
    
    // í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ì— íŒŒì¼ ë³µì‚¬
    for (const [filename, content] of Object.entries(templateFiles)) {
      await this.writeFile(`${projectPath}/${filename}`, content)
    }
    
    // package.json ì„¤ì •
    await this.setupProjectConfig(templateId, projectPath)
  }
  
  private async setupProjectConfig(templateId: string, projectPath: string): Promise<void> {
    const metadata = await this.getTemplateMetadata(templateId)
    
    const packageJson = {
      name: `windwalker-project-${Date.now()}`,
      version: '1.0.0',
      description: metadata.description,
      scripts: {
        dev: 'vite',
        build: 'vite build',
        preview: 'vite preview'
      },
      dependencies: metadata.dependencies || {},
      devDependencies: {
        'vite': '^4.0.0'
      }
    }
    
    await this.writeFile(
      `${projectPath}/package.json`, 
      JSON.stringify(packageJson, null, 2)
    )
  }
}

// 5. í…œí”Œë¦¿ ë§¤ë‹ˆì € í™•ì¥
class EnhancedTemplateManager extends TemplateManager {
  private fileManager: TemplateFileManager
  
  constructor() {
    super()
    this.fileManager = new TemplateFileManager()
  }
  
  async applyTemplate(
    templateId: string, 
    projectPath: string, 
    customizations?: TemplateCustomization
  ): Promise<ApplyTemplateResult> {
    
    try {
      // 1. í…œí”Œë¦¿ íŒŒì¼ ì ìš©
      await this.fileManager.applyTemplateToProject(templateId, projectPath)
      
      // 2. ì»¤ìŠ¤í„°ë§ˆì´ì§• ì ìš© (ìˆëŠ” ê²½ìš°)
      if (customizations) {
        await this.applyCustomizations(templateId, projectPath, customizations)
      }
      
      // 3. ë¹Œë“œ ì„¤ì •
      await this.setupBuildConfiguration(templateId, projectPath)
      
      return {
        success: true,
        templateId,
        projectPath,
        appliedAt: Date.now(),
        customizations: customizations || null
      }
      
    } catch (error) {
      return {
        success: false,
        templateId,
        projectPath,
        error: error.message,
        appliedAt: Date.now()
      }
    }
  }
}
```

### Week 4: AI ì˜ë„ ë¶„ì„ ì‹œìŠ¤í…œ

#### ğŸ¯ ëª©í‘œ
ì‚¬ìš©ì ì…ë ¥ì„ ë¶„ì„í•˜ì—¬ ì˜ë„ë¥¼ íŒŒì•…í•˜ê³  ì ì ˆí•œ í…œí”Œë¦¿ì„ ì¶”ì²œí•˜ëŠ” AI ì‹œìŠ¤í…œ êµ¬í˜„

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 22-23: ì˜ë„ ë¶„ì„ AI í”„ë¡¬í”„íŠ¸ ê°œë°œ
```typescript
// 1. ì˜ë„ ë¶„ì„ í”„ë¡¬í”„íŠ¸ ì‹œìŠ¤í…œ
class IntentAnalyzer {
  private llmService: LLMService
  
  constructor(llmService: LLMService) {
    this.llmService = llmService
  }
  
  async analyzeUserIntent(
    userInput: string, 
    context?: ConversationContext
  ): Promise<UserIntent> {
    
    const prompt = this.buildAnalysisPrompt(userInput, context)
    const response = await this.llmService.generateResponse(prompt)
    
    return this.parseIntentResponse(response)
  }
  
  private buildAnalysisPrompt(userInput: string, context?: ConversationContext): string {
    return `
ì‚¬ìš©ì ì…ë ¥ì„ ë¶„ì„í•˜ì—¬ ì›¹ì‚¬ì´íŠ¸ êµ¬ì¶• ì˜ë„ë¥¼ íŒŒì•…í•´ì£¼ì„¸ìš”.

ì‚¬ìš©ì ì…ë ¥: "${userInput}"

${context ? `ëŒ€í™” ë§¥ë½: ${this.formatContext(context)}` : ''}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ JSON ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "businessType": "blog|ecommerce|portfolio|restaurant|corporate|landing",
  "purpose": "showcase|sales|information|engagement|branding",
  "industry": "í•´ë‹¹ ì‚°ì—… ë¶„ì•¼",
  "targetAudience": "ì£¼ìš” íƒ€ê²Ÿì¸µ",
  "requiredFeatures": ["ê¸°ëŠ¥1", "ê¸°ëŠ¥2", ...],
  "designPreferences": {
    "style": "modern|classic|minimalist|bold",
    "colors": ["ìƒ‰ìƒ1", "ìƒ‰ìƒ2", ...],
    "layout": "grid|list|card|magazine"
  },
  "businessInfo": {
    "name": "ë¹„ì¦ˆë‹ˆìŠ¤ ì´ë¦„ (ìˆëŠ” ê²½ìš°)",
    "description": "ê°„ë‹¨í•œ ì„¤ëª…"
  },
  "confidence": 0.85,
  "reasoning": ["íŒë‹¨ ê·¼ê±°1", "íŒë‹¨ ê·¼ê±°2", ...]
}

ë¶„ì„ ì‹œ ê³ ë ¤ì‚¬í•­:
- ëª…ì‹œì  í‚¤ì›Œë“œ: "ì‡¼í•‘ëª°", "ë¸”ë¡œê·¸", "í¬íŠ¸í´ë¦¬ì˜¤" ë“±
- ì•”ì‹œì  ì˜ë„: "ì œí’ˆ íŒë§¤", "ì‘í’ˆ ì „ì‹œ", "íšŒì‚¬ ì†Œê°œ" ë“±  
- ì—…ì¢… ì •ë³´: "ì¹´í˜", "ë””ìì´ë„ˆ", "ê°œë°œì" ë“±
- ë””ìì¸ ì„ í˜¸: "ê¹”ë”í•œ", "í™”ë ¤í•œ", "ì‹¬í”Œí•œ" ë“±
`
  }
  
  private parseIntentResponse(response: string): UserIntent {
    try {
      const parsed = JSON.parse(response)
      
      // ìœ íš¨ì„± ê²€ì¦
      this.validateIntentResponse(parsed)
      
      return {
        businessType: parsed.businessType,
        purpose: parsed.purpose,
        industry: parsed.industry,
        targetAudience: parsed.targetAudience,
        requiredFeatures: parsed.requiredFeatures || [],
        designPreferences: parsed.designPreferences || {},
        businessInfo: parsed.businessInfo || {},
        confidence: Math.min(Math.max(parsed.confidence || 0.5, 0), 1),
        reasoning: parsed.reasoning || [],
        analyzedAt: Date.now()
      }
      
    } catch (error) {
      console.warn('Failed to parse intent response:', error)
      return this.createFallbackIntent(response)
    }
  }
}
```

##### Day 24-25: ì§€ëŠ¥í˜• í…œí”Œë¦¿ ì¶”ì²œ ì—”ì§„
```typescript
// 2. ì¶”ì²œ ì—”ì§„ êµ¬í˜„
class IntelligentRecommendationEngine {
  private templateManager: TemplateManager
  private intentAnalyzer: IntentAnalyzer
  
  async generateRecommendations(
    userInput: string,
    context?: ConversationContext
  ): Promise<TemplateRecommendation[]> {
    
    // 1. ì˜ë„ ë¶„ì„
    const intent = await this.intentAnalyzer.analyzeUserIntent(userInput, context)
    
    // 2. í…œí”Œë¦¿ í›„ë³´ ê²€ìƒ‰
    const candidates = await this.findCandidateTemplates(intent)
    
    // 3. ìŠ¤ì½”ì–´ë§ ë° ë­í‚¹
    const scoredTemplates = await this.scoreTemplates(candidates, intent, context)
    
    // 4. ìƒìœ„ 3ê°œ ì¶”ì²œ
    const topRecommendations = scoredTemplates
      .sort((a, b) => b.score - a.score)
      .slice(0, 3)
    
    return topRecommendations.map(scored => ({
      template: scored.template,
      confidence: scored.score,
      reasons: this.generateReasons(scored.template, intent, scored.analysis),
      customizationSuggestions: this.generateCustomizationSuggestions(scored.template, intent)
    }))
  }
  
  private async scoreTemplates(
    candidates: TemplateMetadata[],
    intent: UserIntent,
    context?: ConversationContext
  ): Promise<ScoredTemplate[]> {
    
    return Promise.all(candidates.map(async template => {
      let score = 0
      const analysis: ScoreAnalysis = {}
      
      // ë¹„ì¦ˆë‹ˆìŠ¤ íƒ€ì… ë§¤ì¹­ (40%)
      if (template.category === intent.businessType) {
        score += 0.4
        analysis.businessTypeMatch = 'exact'
      } else if (this.isCategoryCompatible(template.category, intent.businessType)) {
        score += 0.2
        analysis.businessTypeMatch = 'compatible'
      }
      
      // ê¸°ëŠ¥ ë§¤ì¹­ (30%)
      const featureMatchScore = this.calculateFeatureMatch(template.keyFeatures, intent.requiredFeatures)
      score += featureMatchScore * 0.3
      analysis.featureMatchScore = featureMatchScore
      analysis.matchingFeatures = this.findMatchingFeatures(template.keyFeatures, intent.requiredFeatures)
      
      // ì‚°ì—… ë§¤ì¹­ (20%)
      const industryMatchScore = this.calculateIndustryMatch(template.industry, intent.industry)
      score += industryMatchScore * 0.2
      analysis.industryMatchScore = industryMatchScore
      
      // ë””ìì¸ ì„ í˜¸ë„ ë§¤ì¹­ (10%)
      const designMatchScore = this.calculateDesignMatch(template.tags, intent.designPreferences)
      score += designMatchScore * 0.1
      analysis.designMatchScore = designMatchScore
      
      // ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ê°œì¸í™” ë³´ì •
      if (context && context.userBehaviorProfile) {
        const personalizedBoost = this.calculatePersonalizedBoost(template, context.userBehaviorProfile)
        score *= (1 + personalizedBoost)
        analysis.personalizedBoost = personalizedBoost
      }
      
      return {
        template,
        score: Math.min(score, 1.0),
        analysis
      }
    }))
  }
  
  private generateReasons(
    template: TemplateMetadata,
    intent: UserIntent,
    analysis: ScoreAnalysis
  ): string[] {
    
    const reasons: string[] = []
    
    // ë¹„ì¦ˆë‹ˆìŠ¤ íƒ€ì… ë§¤ì¹­
    if (analysis.businessTypeMatch === 'exact') {
      reasons.push(`${intent.businessType} ì¹´í…Œê³ ë¦¬ì— ì™„ë²½í•˜ê²Œ ë§ìŠµë‹ˆë‹¤`)
    } else if (analysis.businessTypeMatch === 'compatible') {
      reasons.push(`${intent.businessType}ê³¼ í˜¸í™˜ë˜ëŠ” ë””ìì¸ì…ë‹ˆë‹¤`)
    }
    
    // ê¸°ëŠ¥ ë§¤ì¹­
    if (analysis.matchingFeatures && analysis.matchingFeatures.length > 0) {
      reasons.push(`ìš”ì²­í•˜ì‹  ${analysis.matchingFeatures.join(', ')} ê¸°ëŠ¥ì„ ì§€ì›í•©ë‹ˆë‹¤`)
    }
    
    // ì‚°ì—… ë§¤ì¹­
    if (analysis.industryMatchScore > 0.7) {
      reasons.push(`${intent.industry} ì—…ì¢…ì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤`)
    }
    
    // ë””ìì¸ ì„ í˜¸ë„
    if (analysis.designMatchScore > 0.5 && intent.designPreferences.style) {
      reasons.push(`ì„ í˜¸í•˜ì‹œëŠ” ${intent.designPreferences.style} ìŠ¤íƒ€ì¼ì„ ë°˜ì˜í–ˆìŠµë‹ˆë‹¤`)
    }
    
    // ê°œì¸í™”
    if (analysis.personalizedBoost && analysis.personalizedBoost > 0.1) {
      reasons.push('ì´ì „ ì„ íƒ íŒ¨í„´ì„ ë°”íƒ•ìœ¼ë¡œ ì¶”ì²œë“œë¦½ë‹ˆë‹¤')
    }
    
    return reasons
  }
}
```

#### âœ… Phase 2 ì™„ë£Œ ê¸°ì¤€
- [ ] 5ê°œ í…œí”Œë¦¿ ë©”íƒ€ë°ì´í„° ë° íŒŒì¼ ì™„ì„±
- [ ] AI ì˜ë„ ë¶„ì„ 80% ì´ìƒ ì •í™•ë„
- [ ] í…œí”Œë¦¿ ì¶”ì²œ ì‹œìŠ¤í…œ ë™ì‘ í™•ì¸
- [ ] ì‚¬ìš©ì ì…ë ¥ â†’ í…œí”Œë¦¿ ì¶”ì²œ ì „ì²´ í”Œë¡œìš° ì„±ê³µ

---

## âš™ï¸ Phase 3: ì»¤ìŠ¤í„°ë§ˆì´ì§• ì—”ì§„ ë° ì œì•½ì¡°ê±´ ì‹œìŠ¤í…œ (3ì£¼)

### Week 5-6: ì»¤ìŠ¤í„°ë§ˆì´ì§• ì—”ì§„ êµ¬í˜„

#### ğŸ¯ ëª©í‘œ
ì‚¬ìš©ì ìš”ì²­ì„ ë¶„ì„í•˜ì—¬ 3ê°€ì§€ ê°•ë„ì˜ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ì„ ìƒì„±í•˜ëŠ” ì—”ì§„ êµ¬í˜„

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 26-28: ì»¤ìŠ¤í„°ë§ˆì´ì§• ìš”ì²­ ë¶„ì„ ì‹œìŠ¤í…œ
```typescript
// 1. ì»¤ìŠ¤í„°ë§ˆì´ì§• ìš”ì²­ ë¶„ì„ê¸°
class CustomizationRequestAnalyzer {
  private llmService: LLMService
  
  async analyzeRequest(
    request: string,
    currentProject: ProjectState,
    context: ConversationContext
  ): Promise<CustomizationAnalysis> {
    
    const prompt = this.buildAnalysisPrompt(request, currentProject, context)
    const response = await this.llmService.generateResponse(prompt)
    
    return this.parseAnalysisResponse(response)
  }
  
  private buildAnalysisPrompt(
    request: string,
    project: ProjectState,
    context: ConversationContext
  ): string {
    
    return `
ì‚¬ìš©ìì˜ ì›¹ì‚¬ì´íŠ¸ ì»¤ìŠ¤í„°ë§ˆì´ì§• ìš”ì²­ì„ ë¶„ì„í•´ì£¼ì„¸ìš”.

í˜„ì¬ í…œí”Œë¦¿: ${project.templateBase.name} (${project.templateBase.category})
ì‚¬ìš©ì ìš”ì²­: "${request}"
ëŒ€í™” ë§¥ë½: ${this.formatConversationContext(context)}

ë¶„ì„í•´ì•¼ í•  í•­ëª©:
1. ìˆ˜ì • ëŒ€ìƒ ì»´í¬ë„ŒíŠ¸/ì˜ì—­
2. ìˆ˜ì • ìœ í˜• (ìƒ‰ìƒ, ë ˆì´ì•„ì›ƒ, ì½˜í…ì¸ , í°íŠ¸, ê¸°ëŠ¥)
3. êµ¬ì²´ì„± ìˆ˜ì¤€ (êµ¬ì²´ì , ë³´í†µ, ëª¨í˜¸í•¨)
4. ì˜ë„ ëª…í™•ì„± (ëª…í™•, ë³´í†µ, ë¶ˆëª…í™•)
5. ê¸°ìˆ ì  ë³µì¡ë„ (ë‚®ìŒ, ë³´í†µ, ë†’ìŒ)

ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "targetComponent": "header|content|footer|navigation|sidebar|å…¨ì²´",
  "changeType": "color|layout|content|typography|component|functionality",
  "specificChanges": {
    "colors": {"primary": "#color", "secondary": "#color"},
    "layout": {"type": "grid|flex|absolute", "arrangement": "..."},
    "content": {"text": "...", "images": ["..."]},
    "typography": {"font": "...", "size": "...", "weight": "..."},
    "functionality": ["feature1", "feature2"]
  },
  "specificity": "specific|moderate|vague",
  "intentClarity": "clear|moderate|unclear", 
  "technicalComplexity": "low|medium|high",
  "userExpectation": "conservative|balanced|bold",
  "contextualReferences": ["previous_request_1", "previous_request_2"],
  "confidence": 0.85,
  "reasoning": ["ì´ìœ 1", "ì´ìœ 2", ...]
}

ë¶„ì„ ì˜ˆì‹œ:
- "í—¤ë”ë¥¼ ë” ëª¨ë˜í•˜ê²Œ ë°”ê¿”ì¤˜" â†’ targetComponent: "header", changeType: "layout", specificity: "vague"
- "ë©”ì¸ ìƒ‰ìƒì„ íŒŒë€ìƒ‰(#2563eb)ë¡œ ë³€ê²½" â†’ targetComponent: "ì „ì²´", changeType: "color", specificity: "specific"
- "ìƒí’ˆ ì¹´ë“œ ë ˆì´ì•„ì›ƒì„ 3ì—´ì—ì„œ 4ì—´ë¡œ" â†’ targetComponent: "content", changeType: "layout", specificity: "specific"
`
  }
}
```

##### Day 29-31: 3ê°€ì§€ ê°•ë„ ì˜µì…˜ ìƒì„± ì—”ì§„
```typescript
// 2. ì˜µì…˜ ìƒì„± ì—”ì§„
class CustomizationOptionGenerator {
  private llmService: LLMService
  private constraintEngine: ConstraintEngine
  
  async generateOptions(
    analysis: CustomizationAnalysis,
    project: ProjectState,
    context: ConversationContext
  ): Promise<CustomizationOption[]> {
    
    // 1. ì œì•½ ì¡°ê±´ í™•ì¸
    const constraints = await this.constraintEngine.getConstraints(project, analysis)
    
    // 2. 3ê°€ì§€ ê°•ë„ë³„ ì˜µì…˜ ìƒì„±
    const options = await Promise.all([
      this.generateConservativeOption(analysis, project, constraints, context),
      this.generateBalancedOption(analysis, project, constraints, context),
      this.generateBoldOption(analysis, project, constraints, context)
    ])
    
    return options
  }
  
  private async generateConservativeOption(
    analysis: CustomizationAnalysis,
    project: ProjectState,
    constraints: ProjectConstraints,
    context: ConversationContext
  ): Promise<CustomizationOption> {
    
    const prompt = `
ë³´ìˆ˜ì  ì ‘ê·¼ë²•ìœ¼ë¡œ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ì„ ìƒì„±í•´ì£¼ì„¸ìš”.

ì›ì¹™:
- ê¸°ì¡´ ë””ìì¸ ì–¸ì–´ ìµœëŒ€í•œ ìœ ì§€
- ìµœì†Œí•œì˜ ë³€ê²½ìœ¼ë¡œ ìš”êµ¬ì‚¬í•­ ì¶©ì¡±
- í˜¸í™˜ì„±ê³¼ ì•ˆì •ì„± ìš°ì„ 
- ê¸°ì¡´ ì‚¬ìš©ì ê²½í—˜ íŒ¨í„´ ìœ ì§€

ì‚¬ìš©ì ìš”ì²­ ë¶„ì„: ${JSON.stringify(analysis)}
í˜„ì¬ í”„ë¡œì íŠ¸: ${JSON.stringify(project.templateBase)}
ì œì•½ ì¡°ê±´: ${JSON.stringify(constraints)}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "intensity": "conservative",
  "description": "ë³´ìˆ˜ì  ìˆ˜ì • ì„¤ëª…",
  "changes": {
    "files": {
      "style.css": "/* CSS ë³€ê²½ì‚¬í•­ */",
      "index.html": "<!-- HTML ë³€ê²½ì‚¬í•­ -->"
    },
    "components": {
      "componentName": {"prop": "value"}
    }
  },
  "reasoning": ["ë³€ê²½ ê·¼ê±°1", "ë³€ê²½ ê·¼ê±°2"],
  "technicalImpact": "low",
  "visualImpact": "subtle",
  "estimatedTime": "5ë¶„"
}
`
    
    const response = await this.llmService.generateResponse(prompt)
    return this.parseOptionResponse(response, 'conservative')
  }
  
  private async generateBalancedOption(
    analysis: CustomizationAnalysis,
    project: ProjectState,
    constraints: ProjectConstraints,
    context: ConversationContext
  ): Promise<CustomizationOption> {
    
    const prompt = `
ê· í˜•ì  ì ‘ê·¼ë²•ìœ¼ë¡œ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ì„ ìƒì„±í•´ì£¼ì„¸ìš”.

ì›ì¹™:
- ì ì ˆí•œ ìˆ˜ì¤€ì˜ í˜ì‹ ê³¼ ì•ˆì •ì„±
- ì‚¬ìš©ì ìš”êµ¬ì— ë§ëŠ” ì ê·¹ì  ê°œì„ 
- í˜„ëŒ€ì  ë””ìì¸ íŠ¸ë Œë“œ ë°˜ì˜
- ì‚¬ìš©ì„±ê³¼ ë¯¸ì  ê°€ì¹˜ì˜ ê· í˜•

ì‚¬ìš©ì ìš”ì²­ ë¶„ì„: ${JSON.stringify(analysis)}
í˜„ì¬ í”„ë¡œì íŠ¸: ${JSON.stringify(project.templateBase)}
ì œì•½ ì¡°ê±´: ${JSON.stringify(constraints)}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "intensity": "balanced",
  "description": "ê· í˜•ì  ìˆ˜ì • ì„¤ëª…",
  "changes": {
    "files": {
      "style.css": "/* CSS ë³€ê²½ì‚¬í•­ */",
      "index.html": "<!-- HTML ë³€ê²½ì‚¬í•­ -->"
    },
    "components": {
      "componentName": {"prop": "value"}
    }
  },
  "reasoning": ["ë³€ê²½ ê·¼ê±°1", "ë³€ê²½ ê·¼ê±°2"],
  "technicalImpact": "medium",
  "visualImpact": "noticeable",
  "estimatedTime": "10ë¶„"
}
`
    
    const response = await this.llmService.generateResponse(prompt)
    return this.parseOptionResponse(response, 'balanced')
  }
  
  private async generateBoldOption(
    analysis: CustomizationAnalysis,
    project: ProjectState,
    constraints: ProjectConstraints,
    context: ConversationContext
  ): Promise<CustomizationOption> {
    
    const prompt = `
ëŒ€ë‹´í•œ ì ‘ê·¼ë²•ìœ¼ë¡œ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ì„ ìƒì„±í•´ì£¼ì„¸ìš”.

ì›ì¹™:
- ì°½ì˜ì ì´ê³  í˜ì‹ ì ì¸ ë””ìì¸
- ìµœì‹  ì›¹ ê¸°ìˆ ê³¼ íŠ¸ë Œë“œ ì ê·¹ í™œìš©
- ì‹œê°ì  ì„íŒ©íŠ¸ ê·¹ëŒ€í™”
- ë…íŠ¹í•˜ê³  ê¸°ì–µì— ë‚¨ëŠ” ê²½í—˜ ì œê³µ

ì‚¬ìš©ì ìš”ì²­ ë¶„ì„: ${JSON.stringify(analysis)}
í˜„ì¬ í”„ë¡œì íŠ¸: ${JSON.stringify(project.templateBase)}
ì œì•½ ì¡°ê±´: ${JSON.stringify(constraints)}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "intensity": "bold",
  "description": "ëŒ€ë‹´í•œ ìˆ˜ì • ì„¤ëª…",
  "changes": {
    "files": {
      "style.css": "/* CSS ë³€ê²½ì‚¬í•­ */",
      "index.html": "<!-- HTML ë³€ê²½ì‚¬í•­ -->"
    },
    "components": {
      "componentName": {"prop": "value"}
    }
  },
  "reasoning": ["ë³€ê²½ ê·¼ê±°1", "ë³€ê²½ ê·¼ê±°2"],
  "technicalImpact": "high",
  "visualImpact": "dramatic",
  "estimatedTime": "15ë¶„"
}
`
    
    const response = await this.llmService.generateResponse(prompt)
    return this.parseOptionResponse(response, 'bold')
  }
}
```

##### Day 32-35: ì»¤ìŠ¤í„°ë§ˆì´ì§• ì ìš© ì—”ì§„
```typescript
// 3. ì»¤ìŠ¤í„°ë§ˆì´ì§• ì ìš© ì—”ì§„
class CustomizationApplicator {
  private fileManager: FileManager
  private buildManager: BuildManager
  
  async applyCustomization(
    option: CustomizationOption,
    project: ProjectState
  ): Promise<CustomizationResult> {
    
    try {
      // 1. ë°±ì—… ìƒì„±
      const backup = await this.createBackup(project)
      
      // 2. íŒŒì¼ ë³€ê²½ì‚¬í•­ ì ìš©
      const fileResults = await this.applyFileChanges(option.changes.files, project)
      
      // 3. ì»´í¬ë„ŒíŠ¸ ë³€ê²½ì‚¬í•­ ì ìš©
      const componentResults = await this.applyComponentChanges(option.changes.components, project)
      
      // 4. ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸
      await this.updateProjectConfig(option, project)
      
      // 5. ë¹Œë“œ íŠ¸ë¦¬ê±°
      const buildResult = await this.buildManager.build(project.projectPath)
      
      return {
        success: true,
        appliedOption: option,
        fileChanges: fileResults,
        componentChanges: componentResults,
        buildResult,
        backup,
        appliedAt: Date.now()
      }
      
    } catch (error) {
      // ì—ëŸ¬ ë°œìƒ ì‹œ ë¡¤ë°±
      if (backup) {
        await this.restoreBackup(backup, project)
      }
      
      return {
        success: false,
        appliedOption: option,
        error: error.message,
        appliedAt: Date.now()
      }
    }
  }
  
  private async applyFileChanges(
    fileChanges: Record<string, string>,
    project: ProjectState
  ): Promise<FileChangeResult[]> {
    
    const results: FileChangeResult[] = []
    
    for (const [filename, changes] of Object.entries(fileChanges)) {
      try {
        const filePath = `${project.projectPath}/${filename}`
        
        // ê¸°ì¡´ íŒŒì¼ ì½ê¸°
        const originalContent = await this.fileManager.readFile(filePath)
        
        // ë³€ê²½ì‚¬í•­ ì ìš©
        const newContent = await this.mergeChanges(originalContent, changes, filename)
        
        // íŒŒì¼ ì“°ê¸°
        await this.fileManager.writeFile(filePath, newContent)
        
        results.push({
          filename,
          success: true,
          originalSize: originalContent.length,
          newSize: newContent.length
        })
        
      } catch (error) {
        results.push({
          filename,
          success: false,
          error: error.message
        })
      }
    }
    
    return results
  }
  
  private async mergeChanges(
    originalContent: string,
    changes: string,
    filename: string
  ): Promise<string> {
    
    const fileExtension = filename.split('.').pop()
    
    switch (fileExtension) {
      case 'css':
        return this.mergeCSSChanges(originalContent, changes)
      case 'html':
        return this.mergeHTMLChanges(originalContent, changes)
      case 'js':
        return this.mergeJSChanges(originalContent, changes)
      default:
        throw new Error(`Unsupported file type: ${fileExtension}`)
    }
  }
  
  private mergeCSSChanges(original: string, changes: string): string {
    // CSS ë³€ê²½ì‚¬í•­ ë³‘í•© ë¡œì§
    // 1. CSS íŒŒì‹±
    // 2. ë³€ê²½ì‚¬í•­ ì‹ë³„ ë° ì ìš©
    // 3. ìµœì í™”ëœ CSS ìƒì„±
    
    // ê°„ë‹¨í•œ êµ¬í˜„ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ CSS íŒŒì„œ í•„ìš”)
    const newRules = this.extractCSSRules(changes)
    let updatedCSS = original
    
    for (const rule of newRules) {
      if (this.cssRuleExists(original, rule.selector)) {
        // ê¸°ì¡´ ë£° ì—…ë°ì´íŠ¸
        updatedCSS = this.updateCSSRule(updatedCSS, rule)
      } else {
        // ìƒˆ ë£° ì¶”ê°€
        updatedCSS += `\n\n${rule.selector} {\n${rule.properties}\n}`
      }
    }
    
    return updatedCSS
  }
}
```

### Week 7: ì œì•½ì¡°ê±´ ì‹œìŠ¤í…œ êµ¬í˜„

#### ğŸ¯ ëª©í‘œ
ì»¤ìŠ¤í„°ë§ˆì´ì§• ìš”ì²­ì˜ ê¸°ìˆ ì /ë””ìì¸ì  ì œì•½ì¡°ê±´ì„ ê²€ì¦í•˜ê³  í•´ê²°ë°©ì•ˆì„ ì œì‹œí•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 36-38: ì œì•½ì¡°ê±´ ì—”ì§„ êµ¬í˜„
```typescript
// 1. ì œì•½ì¡°ê±´ ì—”ì§„
class AdvancedConstraintEngine {
  private rules: ConstraintRule[] = []
  private validators: Map<string, ConstraintValidator> = new Map()
  
  constructor() {
    this.initializeValidators()
    this.loadConstraintRules()
  }
  
  private initializeValidators(): void {
    this.validators.set('technical', new TechnicalConstraintValidator())
    this.validators.set('design', new DesignConstraintValidator())
    this.validators.set('accessibility', new AccessibilityConstraintValidator())
    this.validators.set('performance', new PerformanceConstraintValidator())
    this.validators.set('business', new BusinessConstraintValidator())
  }
  
  async validateRequest(
    analysis: CustomizationAnalysis,
    project: ProjectState
  ): Promise<ValidationResult> {
    
    const results = await Promise.all(
      Array.from(this.validators.entries()).map(async ([type, validator]) => {
        const result = await validator.validate(analysis, project)
        return { type, ...result }
      })
    )
    
    const violations = results.flatMap(r => r.violations || [])
    const warnings = results.flatMap(r => r.warnings || [])
    const suggestions = results.flatMap(r => r.suggestions || [])
    
    return {
      isValid: violations.length === 0,
      violations,
      warnings,
      suggestions,
      validationResults: results,
      
      // í•´ê²° ì „ëµ ìƒì„±
      resolutionStrategies: this.generateResolutionStrategies(violations, warnings),
      alternativeApproaches: this.generateAlternatives(analysis, violations)
    }
  }
}

// 2. ê¸°ìˆ ì  ì œì•½ì¡°ê±´ ê²€ì¦ê¸°
class TechnicalConstraintValidator implements ConstraintValidator {
  async validate(
    analysis: CustomizationAnalysis,
    project: ProjectState
  ): Promise<ConstraintValidationResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    const suggestions: ConstraintSuggestion[] = []
    
    // ì»´í¬ë„ŒíŠ¸ í˜¸í™˜ì„± ê²€ì‚¬
    if (analysis.targetComponent) {
      const componentCheck = await this.validateComponentCompatibility(
        analysis.targetComponent, 
        project
      )
      violations.push(...componentCheck.violations)
      warnings.push(...componentCheck.warnings)
    }
    
    // ì˜ì¡´ì„± ê²€ì‚¬
    if (analysis.specificChanges.functionality) {
      const dependencyCheck = await this.validateDependencies(
        analysis.specificChanges.functionality,
        project
      )
      warnings.push(...dependencyCheck.warnings)
      suggestions.push(...dependencyCheck.suggestions)
    }
    
    // íŒŒì¼ êµ¬ì¡° ê²€ì‚¬
    const fileStructureCheck = await this.validateFileStructure(analysis, project)
    violations.push(...fileStructureCheck.violations)
    
    // ë¹Œë“œ ì‹œìŠ¤í…œ í˜¸í™˜ì„±
    const buildCompatibilityCheck = await this.validateBuildCompatibility(analysis, project)
    warnings.push(...buildCompatibilityCheck.warnings)
    
    return {
      violations,
      warnings,
      suggestions
    }
  }
  
  private async validateComponentCompatibility(
    targetComponent: string,
    project: ProjectState
  ): Promise<ComponentValidationResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    
    // í…œí”Œë¦¿ì— í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    const componentExists = project.templateBase.aiCapabilities.customizationPoints
      .some(point => point.id === targetComponent || point.name.toLowerCase().includes(targetComponent.toLowerCase()))
    
    if (!componentExists) {
      violations.push({
        type: 'component:not-found',
        severity: 'error',
        message: `ì»´í¬ë„ŒíŠ¸ '${targetComponent}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
        component: targetComponent,
        suggestions: this.suggestSimilarComponents(targetComponent, project)
      })
    }
    
    // ì»´í¬ë„ŒíŠ¸ ìˆ˜ì • ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    const customizationPoint = project.templateBase.aiCapabilities.customizationPoints
      .find(point => point.id === targetComponent)
    
    if (customizationPoint && customizationPoint.constraintRules) {
      const ruleViolations = this.checkComponentRules(customizationPoint.constraintRules)
      violations.push(...ruleViolations)
    }
    
    return { violations, warnings }
  }
}

// 3. ë””ìì¸ ì œì•½ì¡°ê±´ ê²€ì¦ê¸°
class DesignConstraintValidator implements ConstraintValidator {
  async validate(
    analysis: CustomizationAnalysis,
    project: ProjectState
  ): Promise<ConstraintValidationResult> {
    
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    const suggestions: ConstraintSuggestion[] = []
    
    // ìƒ‰ìƒ ê´€ë ¨ ê²€ì¦
    if (analysis.specificChanges.colors) {
      const colorValidation = await this.validateColors(analysis.specificChanges.colors)
      violations.push(...colorValidation.violations)
      warnings.push(...colorValidation.warnings)
      suggestions.push(...colorValidation.suggestions)
    }
    
    // ë ˆì´ì•„ì›ƒ ê´€ë ¨ ê²€ì¦
    if (analysis.specificChanges.layout) {
      const layoutValidation = await this.validateLayout(analysis.specificChanges.layout, project)
      violations.push(...layoutValidation.violations)
      warnings.push(...layoutValidation.warnings)
    }
    
    // íƒ€ì´í¬ê·¸ë˜í”¼ ê²€ì¦
    if (analysis.specificChanges.typography) {
      const typographyValidation = await this.validateTypography(analysis.specificChanges.typography)
      warnings.push(...typographyValidation.warnings)
      suggestions.push(...typographyValidation.suggestions)
    }
    
    return {
      violations,
      warnings,
      suggestions
    }
  }
  
  private async validateColors(colors: Record<string, string>): Promise<ColorValidationResult> {
    const violations: ConstraintViolation[] = []
    const warnings: ConstraintWarning[] = []
    const suggestions: ConstraintSuggestion[] = []
    
    for (const [colorName, colorValue] of Object.entries(colors)) {
      // ìƒ‰ìƒ í˜•ì‹ ê²€ì¦
      if (!this.isValidColorFormat(colorValue)) {
        violations.push({
          type: 'color:invalid-format',
          severity: 'error',
          message: `ìœ íš¨í•˜ì§€ ì•Šì€ ìƒ‰ìƒ í˜•ì‹: ${colorValue}`,
          value: colorValue,
          suggestions: ['#000000', 'rgb(0,0,0)', 'hsl(0,0%,0%)']
        })
      }
      
      // ì ‘ê·¼ì„± ê²€ì‚¬ (ëŒ€ë¹„ìœ¨)
      if (colorName === 'primary' && colors.background) {
        const contrastRatio = this.calculateContrastRatio(colorValue, colors.background)
        if (contrastRatio < 4.5) {
          warnings.push({
            type: 'accessibility:color-contrast',
            severity: 'warning',
            message: `ìƒ‰ìƒ ëŒ€ë¹„ê°€ WCAG AA ê¸°ì¤€(4.5:1)ì„ ì¶©ì¡±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (í˜„ì¬: ${contrastRatio.toFixed(2)}:1)`,
            currentValue: contrastRatio,
            requiredValue: 4.5
          })
          
          suggestions.push({
            type: 'color:contrast-improvement',
            title: 'ëŒ€ë¹„ ê°œì„ ',
            description: 'WCAG ê¸°ì¤€ì„ ë§Œì¡±í•˜ëŠ” ìƒ‰ìƒìœ¼ë¡œ ìë™ ì¡°ì •',
            suggestedColors: this.generateAccessibleColors(colorValue, colors.background)
          })
        }
      }
    }
    
    return { violations, warnings, suggestions }
  }
}
```

##### Day 39-42: í•´ê²° ì „ëµ ë° ëŒ€ì•ˆ ì œì‹œ ì‹œìŠ¤í…œ
```typescript
// 4. í•´ê²° ì „ëµ ìƒì„±ê¸°
class ResolutionStrategyGenerator {
  generateStrategies(
    violations: ConstraintViolation[],
    warnings: ConstraintWarning[],
    analysis: CustomizationAnalysis
  ): ResolutionStrategy[] {
    
    const strategies: ResolutionStrategy[] = []
    
    // ìœ„ë°˜ ì‚¬í•­ë³„ í•´ê²° ì „ëµ
    for (const violation of violations) {
      const strategy = this.createViolationStrategy(violation, analysis)
      if (strategy) {
        strategies.push(strategy)
      }
    }
    
    // ê²½ê³  ì‚¬í•­ë³„ ê°œì„  ì „ëµ
    for (const warning of warnings) {
      const strategy = this.createWarningStrategy(warning, analysis)
      if (strategy) {
        strategies.push(strategy)
      }
    }
    
    return strategies
  }
  
  private createViolationStrategy(
    violation: ConstraintViolation,
    analysis: CustomizationAnalysis
  ): ResolutionStrategy | null {
    
    switch (violation.type) {
      case 'component:not-found':
        return {
          violationType: violation.type,
          strategy: 'alternative_component',
          title: 'ëŒ€ì²´ ì»´í¬ë„ŒíŠ¸ ì œì•ˆ',
          description: `'${violation.component}' ëŒ€ì‹  ìˆ˜ì • ê°€ëŠ¥í•œ ìœ ì‚¬ ì»´í¬ë„ŒíŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤`,
          actionRequired: 'user_approval',
          estimatedImpact: 'medium',
          alternatives: violation.suggestions || [],
          autoApplicable: false
        }
        
      case 'accessibility:color-contrast':
        return {
          violationType: violation.type,
          strategy: 'contrast_adjustment',
          title: 'ìƒ‰ìƒ ëŒ€ë¹„ ìë™ ì¡°ì •',
          description: 'WCAG AA ê¸°ì¤€ì„ ë§Œì¡±í•˜ë„ë¡ ìƒ‰ìƒì„ ìë™ìœ¼ë¡œ ì¡°ì •í•©ë‹ˆë‹¤',
          actionRequired: 'automatic',
          estimatedImpact: 'low',
          adjustments: this.calculateContrastAdjustments(violation),
          autoApplicable: true
        }
        
      case 'responsive:incompatible':
        return {
          violationType: violation.type,
          strategy: 'responsive_adaptation',
          title: 'ë°˜ì‘í˜• ë ˆì´ì•„ì›ƒ ìë™ ì ì‘',
          description: 'ëª¨ë°”ì¼ í™˜ê²½ì—ì„œë„ ì ì ˆíˆ í‘œì‹œë˜ë„ë¡ ë ˆì´ì•„ì›ƒì„ ì¡°ì •í•©ë‹ˆë‹¤',
          actionRequired: 'automatic',
          estimatedImpact: 'medium',
          adaptations: this.generateResponsiveAdaptations(violation),
          autoApplicable: true
        }
        
      default:
        return null
    }
  }
  
  private createWarningStrategy(
    warning: ConstraintWarning,
    analysis: CustomizationAnalysis
  ): ResolutionStrategy | null {
    
    switch (warning.type) {
      case 'performance:large-impact':
        return {
          violationType: warning.type,
          strategy: 'performance_optimization',
          title: 'ì„±ëŠ¥ ìµœì í™”',
          description: 'ë³€ê²½ì‚¬í•­ì˜ ì„±ëŠ¥ ì˜í–¥ì„ ìµœì†Œí™”í•˜ëŠ” ìµœì í™”ë¥¼ ì ìš©í•©ë‹ˆë‹¤',
          actionRequired: 'recommended',
          estimatedImpact: 'low',
          optimizations: this.generatePerformanceOptimizations(warning),
          autoApplicable: true
        }
        
      case 'dependency:missing':
        return {
          violationType: warning.type,
          strategy: 'dependency_installation',
          title: 'í•„ìš”í•œ ì˜ì¡´ì„± ì„¤ì¹˜',
          description: 'ìš”ì²­í•œ ê¸°ëŠ¥ì„ ìœ„í•´ í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤',
          actionRequired: 'user_approval',
          estimatedImpact: 'medium',
          dependencies: warning.requiredDependencies || [],
          autoApplicable: false
        }
        
      default:
        return null
    }
  }
}

// 5. ëŒ€ì•ˆ ìƒì„±ê¸°
class AlternativeApproachGenerator {
  generateAlternatives(
    analysis: CustomizationAnalysis,
    violations: ConstraintViolation[]
  ): AlternativeApproach[] {
    
    const alternatives: AlternativeApproach[] = []
    
    // ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ ëŒ€ì•ˆ
    const componentAlternatives = this.generateComponentAlternatives(analysis, violations)
    alternatives.push(...componentAlternatives)
    
    // ê¸°ìˆ ì  ì ‘ê·¼ë²• ëŒ€ì•ˆ
    const technicalAlternatives = this.generateTechnicalAlternatives(analysis, violations)
    alternatives.push(...technicalAlternatives)
    
    // ë””ìì¸ ì ‘ê·¼ë²• ëŒ€ì•ˆ
    const designAlternatives = this.generateDesignAlternatives(analysis, violations)
    alternatives.push(...designAlternatives)
    
    return alternatives.sort((a, b) => b.feasibilityScore - a.feasibilityScore)
  }
  
  private generateComponentAlternatives(
    analysis: CustomizationAnalysis,
    violations: ConstraintViolation[]
  ): AlternativeApproach[] {
    
    const alternatives: AlternativeApproach[] = []
    
    const componentViolations = violations.filter(v => v.type.startsWith('component:'))
    
    for (const violation of componentViolations) {
      if (violation.suggestions && violation.suggestions.length > 0) {
        alternatives.push({
          type: 'component_alternative',
          title: `${violation.component} ëŒ€ì²´ ì»´í¬ë„ŒíŠ¸`,
          description: `${violation.component} ëŒ€ì‹  ìˆ˜ì • ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ ì‚¬ìš©`,
          approach: {
            originalTarget: violation.component,
            alternativeTargets: violation.suggestions,
            adaptationRequired: true
          },
          feasibilityScore: 0.8,
          estimatedEffort: 'medium',
          pros: ['ìˆ˜ì • ê°€ëŠ¥', 'ì•ˆì •ì ', 'í˜¸í™˜ì„± ë³´ì¥'],
          cons: ['ìœ„ì¹˜ ë³€ê²½', 'ì¼ë¶€ ê¸°ëŠ¥ ì œí•œ']
        })
      }
    }
    
    return alternatives
  }
}
```

#### âœ… Phase 3 ì™„ë£Œ ê¸°ì¤€
- [ ] ì»¤ìŠ¤í„°ë§ˆì´ì§• ìš”ì²­ ë¶„ì„ 90% ì´ìƒ ì •í™•ë„
- [ ] 3ê°€ì§€ ê°•ë„ ì˜µì…˜ ìƒì„± ì‹œìŠ¤í…œ ë™ì‘
- [ ] ì œì•½ì¡°ê±´ ê²€ì¦ ì‹œìŠ¤í…œ ì™„ì„±
- [ ] í•´ê²° ì „ëµ ìë™ ìƒì„± ê¸°ëŠ¥ ë™ì‘
- [ ] ì»¤ìŠ¤í„°ë§ˆì´ì§• ì ìš© ë° ë¡¤ë°± ì‹œìŠ¤í…œ ì™„ì„±

---

## ğŸ­ Phase 4: ë¹„êµ UI ë° ë¯¸ë¦¬ë³´ê¸° ì‹œìŠ¤í…œ (2ì£¼)

### Week 8: ë¹„êµ UI ì‹œìŠ¤í…œ

#### ğŸ¯ ëª©í‘œ
3ê°€ì§€ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ì„ ë¹„êµí•  ìˆ˜ ìˆëŠ” ì§ê´€ì ì¸ UI ì‹œìŠ¤í…œ êµ¬í˜„

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 43-45: React ê¸°ë°˜ ë¹„êµ UI ì»´í¬ë„ŒíŠ¸
```typescript
// 1. ë¹„êµ ë·°ì–´ ë©”ì¸ ì»´í¬ë„ŒíŠ¸
const ComparisonViewer: React.FC<ComparisonViewerProps> = ({
  originalProject,
  customizationOptions,
  onOptionSelect,
  onRegenerate,
  onApply
}) => {
  const [selectedOption, setSelectedOption] = useState<string | null>(null)
  const [viewMode, setViewMode] = useState<'grid' | 'split' | 'carousel'>('grid')
  const [previewStates, setPreviewStates] = useState<Map<string, PreviewState>>(new Map())
  
  // ë¯¸ë¦¬ë³´ê¸° ìƒì„± íš¨ê³¼
  useEffect(() => {
    generatePreviews()
  }, [customizationOptions])
  
  const generatePreviews = async () => {
    const previewPromises = customizationOptions.map(async (option) => {
      try {
        setPreviewStates(prev => new Map(prev.set(option.id, { status: 'generating' })))
        
        const preview = await previewGenerator.generatePreview(option, originalProject)
        
        setPreviewStates(prev => new Map(prev.set(option.id, {
          status: 'ready',
          preview,
          generatedAt: Date.now()
        })))
        
      } catch (error) {
        setPreviewStates(prev => new Map(prev.set(option.id, {
          status: 'error',
          error: error.message
        })))
      }
    })
    
    await Promise.all(previewPromises)
  }
  
  return (
    <div className="comparison-viewer">
      <ComparisonHeader
        viewMode={viewMode}
        onViewModeChange={setViewMode}
        onRegenerate={onRegenerate}
      />
      
      <div className={`comparison-content ${viewMode}`}>
        {/* ì›ë³¸ í”„ë¦¬ë·° */}
        <OriginalPreviewCard
          project={originalProject}
          className="original-preview"
        />
        
        {/* ì˜µì…˜ë³„ ë¯¸ë¦¬ë³´ê¸° */}
        {customizationOptions.map((option) => (
          <CustomizationOptionCard
            key={option.id}
            option={option}
            previewState={previewStates.get(option.id)}
            isSelected={selectedOption === option.id}
            onSelect={() => setSelectedOption(option.id)}
            onPreview={() => handlePreviewFocus(option.id)}
          />
        ))}
      </div>
      
      <ComparisonActions
        selectedOption={selectedOption}
        onApply={() => selectedOption && onApply(selectedOption)}
        onRegenerate={onRegenerate}
        disabled={!selectedOption}
      />
    </div>
  )
}

// 2. ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ ì¹´ë“œ
const CustomizationOptionCard: React.FC<OptionCardProps> = ({
  option,
  previewState,
  isSelected,
  onSelect,
  onPreview
}) => {
  const [isExpanded, setIsExpanded] = useState(false)
  
  return (
    <div 
      className={`option-card ${option.intensity} ${isSelected ? 'selected' : ''}`}
      onClick={onSelect}
      onMouseEnter={onPreview}
    >
      <div className="option-header">
        <div className="option-title">
          <h3>{option.description}</h3>
          <IntensityBadge intensity={option.intensity} />
        </div>
        <div className="option-actions">
          <button 
            className="expand-btn"
            onClick={(e) => {
              e.stopPropagation()
              setIsExpanded(!isExpanded)
            }}
          >
            {isExpanded ? 'ì ‘ê¸°' : 'ìì„¸íˆ'}
          </button>
        </div>
      </div>
      
      <div className="option-preview">
        {previewState?.status === 'generating' && (
          <PreviewLoadingState />
        )}
        
        {previewState?.status === 'ready' && (
          <PreviewImage
            src={previewState.preview.screenshot}
            alt={option.description}
            onFullscreen={() => openFullscreenPreview(previewState.preview)}
          />
        )}
        
        {previewState?.status === 'error' && (
          <PreviewErrorState error={previewState.error} />
        )}
      </div>
      
      {isExpanded && (
        <div className="option-details">
          <div className="reasoning-section">
            <h4>ë³€ê²½ ì´ìœ </h4>
            <ul>
              {option.reasoning.map((reason, index) => (
                <li key={index}>{reason}</li>
              ))}
            </ul>
          </div>
          
          <div className="technical-info">
            <div className="info-item">
              <span className="label">ê¸°ìˆ ì  ì˜í–¥:</span>
              <TechnicalImpactBadge impact={option.technicalImpact} />
            </div>
            <div className="info-item">
              <span className="label">ì‹œê°ì  ë³€í™”:</span>
              <VisualImpactBadge impact={option.visualImpact} />
            </div>
            <div className="info-item">
              <span className="label">ì˜ˆìƒ ì‹œê°„:</span>
              <span>{option.estimatedTime}</span>
            </div>
          </div>
          
          {option.constraints && option.constraints.length > 0 && (
            <div className="constraints-section">
              <h4>ì ìš©ëœ ì œì•½ ì¡°ê±´</h4>
              <ul>
                {option.constraints.map((constraint, index) => (
                  <li key={index} className={`constraint ${constraint.severity}`}>
                    {constraint.message}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}
      
      <div className="option-footer">
        <div className="preview-metrics">
          {previewState?.preview && (
            <>
              <span>ë¹Œë“œ ì‹œê°„: {previewState.preview.buildTime}ms</span>
              <span>íŒŒì¼ í¬ê¸°: {previewState.preview.fileSize}KB</span>
            </>
          )}
        </div>
        
        <div className="selection-indicator">
          {isSelected && <CheckCircleIcon className="selected-icon" />}
        </div>
      </div>
    </div>
  )
}
```

##### Day 46-49: ë·° ëª¨ë“œ ë° ìƒí˜¸ì‘ìš© ê¸°ëŠ¥
```typescript
// 3. ë·° ëª¨ë“œë³„ ë ˆì´ì•„ì›ƒ
const ViewModeLayouts = {
  grid: {
    className: 'comparison-grid',
    itemsPerRow: 2,
    showMinimap: true
  },
  split: {
    className: 'comparison-split',
    itemsPerRow: 1,
    showSideBySide: true
  },
  carousel: {
    className: 'comparison-carousel',
    itemsPerRow: 1,
    showNavigation: true
  }
}

// 4. ì „ì²´í™”ë©´ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬
const FullscreenPreviewModal: React.FC<FullscreenModalProps> = ({
  preview,
  isOpen,
  onClose
}) => {
  const [currentDevice, setCurrentDevice] = useState<'desktop' | 'tablet' | 'mobile'>('desktop')
  
  if (!isOpen) return null
  
  return (
    <div className="fullscreen-modal-overlay" onClick={onClose}>
      <div className="fullscreen-modal-content" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <h2>ë¯¸ë¦¬ë³´ê¸°</h2>
          <div className="device-selector">
            <button 
              className={currentDevice === 'desktop' ? 'active' : ''}
              onClick={() => setCurrentDevice('desktop')}
            >
              ğŸ’» ë°ìŠ¤í¬í†±
            </button>
            <button 
              className={currentDevice === 'tablet' ? 'active' : ''}
              onClick={() => setCurrentDevice('tablet')}
            >
              ğŸ“± íƒœë¸”ë¦¿
            </button>
            <button 
              className={currentDevice === 'mobile' ? 'active' : ''}
              onClick={() => setCurrentDevice('mobile')}
            >
              ğŸ“± ëª¨ë°”ì¼
            </button>
          </div>
          <button className="close-btn" onClick={onClose}>Ã—</button>
        </div>
        
        <div className="modal-body">
          <div className={`preview-frame ${currentDevice}`}>
            <iframe
              src={preview.previewUrl}
              title="Full Preview"
              style={{
                width: getDeviceWidth(currentDevice),
                height: getDeviceHeight(currentDevice)
              }}
            />
          </div>
        </div>
        
        <div className="modal-footer">
          <div className="preview-info">
            <span>ë¹Œë“œ ì‹œê°„: {preview.buildTime}ms</span>
            <span>ìƒíƒœ: {preview.status}</span>
            <span>ìƒì„±ì¼: {new Date(preview.generatedAt).toLocaleString()}</span>
          </div>
          <div className="preview-actions">
            <button onClick={() => window.open(preview.previewUrl, '_blank')}>
              ìƒˆ ì°½ì—ì„œ ì—´ê¸°
            </button>
            <button onClick={() => downloadPreview(preview)}>
              ë‹¤ìš´ë¡œë“œ
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

// 5. í‚¤ë³´ë“œ ë‚´ë¹„ê²Œì´ì…˜ ì§€ì›
const useKeyboardNavigation = (
  options: CustomizationOption[],
  selectedOption: string | null,
  onSelect: (id: string) => void,
  onApply: () => void
) => {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!options || options.length === 0) return
      
      const currentIndex = selectedOption 
        ? options.findIndex(opt => opt.id === selectedOption)
        : -1
      
      switch (e.key) {
        case 'ArrowLeft':
        case 'ArrowUp':
          e.preventDefault()
          const prevIndex = currentIndex > 0 ? currentIndex - 1 : options.length - 1
          onSelect(options[prevIndex].id)
          break
          
        case 'ArrowRight':
        case 'ArrowDown':
          e.preventDefault()
          const nextIndex = currentIndex < options.length - 1 ? currentIndex + 1 : 0
          onSelect(options[nextIndex].id)
          break
          
        case 'Enter':
          e.preventDefault()
          if (selectedOption) {
            onApply()
          }
          break
          
        case 'Escape':
          e.preventDefault()
          onSelect('')
          break
      }
    }
    
    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [options, selectedOption, onSelect, onApply])
}
```

### Week 9: ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì‹œìŠ¤í…œ

#### ğŸ¯ ëª©í‘œ
ì‹¤ì‹œê°„ìœ¼ë¡œ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ì˜ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìƒì„±í•˜ê³  ìµœì í™”í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### Day 50-52: ê³ ì„±ëŠ¥ ë¯¸ë¦¬ë³´ê¸° ìƒì„±ê¸°
```typescript
// 1. ìµœì í™”ëœ ë¯¸ë¦¬ë³´ê¸° ìƒì„±ê¸°
class OptimizedPreviewGenerator {
  private buildCache: Map<string, CachedBuild> = new Map()
  private screenshotService: ScreenshotService
  private previewPool: PreviewInstancePool
  
  constructor() {
    this.screenshotService = new ScreenshotService()
    this.previewPool = new PreviewInstancePool({ maxInstances: 3 })
  }
  
  async generatePreview(
    option: CustomizationOption,
    baseProject: ProjectState
  ): Promise<PreviewResult> {
    
    const startTime = performance.now()
    
    try {
      // 1. ìºì‹œ í™•ì¸
      const cacheKey = this.generateCacheKey(option, baseProject)
      const cached = this.buildCache.get(cacheKey)
      
      if (cached && this.isCacheValid(cached)) {
        return {
          ...cached.result,
          fromCache: true,
          generationTime: performance.now() - startTime
        }
      }
      
      // 2. ë³€ê²½ì‚¬í•­ ë¶„æ
      const changeAnalysis = this.analyzeChanges(option, baseProject)
      
      // 3. ìµœì í™”ëœ ë¹Œë“œ ì „ëµ ì„ íƒ
      const buildStrategy = this.selectBuildStrategy(changeAnalysis)
      
      // 4. ë¯¸ë¦¬ë³´ê¸° ìƒì„±
      const result = await this.generatePreviewWithStrategy(
        option,
        baseProject,
        buildStrategy,
        changeAnalysis
      )
      
      // 5. ìºì‹œì— ì €ì¥
      this.buildCache.set(cacheKey, {
        result,
        createdAt: Date.now(),
        strategy: buildStrategy
      })
      
      return {
        ...result,
        fromCache: false,
        generationTime: performance.now() - startTime
      }
      
    } catch (error) {
      return {
        status: 'error',
        error: error.message,
        generationTime: performance.now() - startTime
      }
    }
  }
  
  private analyzeChanges(
    option: CustomizationOption,
    baseProject: ProjectState
  ): ChangeAnalysis {
    
    const analysis: ChangeAnalysis = {
      affectedFiles: [],
      changeType: 'unknown',
      complexity: 'low',
      canUseHotReload: false,
      canReuseAssets: true,
      requiresFullBuild: false
    }
    
    // íŒŒì¼ ë³€ê²½ì‚¬í•­ ë¶„ì„
    if (option.changes.files) {
      analysis.affectedFiles = Object.keys(option.changes.files)
      
      // CSSë§Œ ë³€ê²½ëœ ê²½ìš° í•« ë¦¬ë¡œë“œ ê°€ëŠ¥
      if (analysis.affectedFiles.every(file => file.endsWith('.css'))) {
        analysis.canUseHotReload = true
        analysis.changeType = 'style-only'
        analysis.complexity = 'low'
      }
      
      // HTML êµ¬ì¡° ë³€ê²½ ì‹œ ì „ì²´ ë¹Œë“œ í•„ìš”
      if (analysis.affectedFiles.some(file => file.endsWith('.html'))) {
        analysis.requiresFullBuild = true
        analysis.changeType = 'structural'
        analysis.complexity = 'medium'
      }
      
      // JS ë³€ê²½ ì‹œ ë³µì¡ë„ ì¦ê°€
      if (analysis.affectedFiles.some(file => file.endsWith('.js'))) {
        analysis.requiresFullBuild = true
        analysis.changeType = 'functional'
        analysis.complexity = 'high'
      }
    }
    
    return analysis
  }
  
  private selectBuildStrategy(analysis: ChangeAnalysis): BuildStrategy {
    if (analysis.canUseHotReload) {
      return 'hot-reload'
    } else if (analysis.complexity === 'low' && !analysis.requiresFullBuild) {
      return 'incremental'
    } else {
      return 'full-build'
    }
  }
  
  private async generatePreviewWithStrategy(
    option: CustomizationOption,
    baseProject: ProjectState,
    strategy: BuildStrategy,
    analysis: ChangeAnalysis
  ): Promise<PreviewResult> {
    
    switch (strategy) {
      case 'hot-reload':
        return await this.generateHotReloadPreview(option, baseProject, analysis)
      case 'incremental':
        return await this.generateIncrementalPreview(option, baseProject, analysis)
      case 'full-build':
        return await this.generateFullBuildPreview(option, baseProject, analysis)
      default:
        throw new Error(`Unknown build strategy: ${strategy}`)
    }
  }
  
  private async generateHotReloadPreview(
    option: CustomizationOption,
    baseProject: ProjectState,
    analysis: ChangeAnalysis
  ): Promise<PreviewResult> {
    
    const instance = await this.previewPool.acquire()
    
    try {
      // ê¸°ì¡´ ë¹Œë“œ ì¬ì‚¬ìš©
      const basePreviewUrl = await this.getBasePreviewUrl(baseProject)
      
      // CSS ë³€ê²½ì‚¬í•­ë§Œ ì£¼ì…
      const styleInjections = this.generateStyleInjections(option.changes.files)
      
      // ì‹¤ì‹œê°„ ìŠ¤íƒ€ì¼ ì ìš©
      const previewUrl = await instance.applyStyleInjection(basePreviewUrl, styleInjections)
      
      // ë¹ ë¥¸ ìŠ¤í¬ë¦°ìƒ· (ë·°í¬íŠ¸ë§Œ)
      const screenshot = await this.screenshotService.captureViewport(previewUrl, {
        width: 1200,
        height: 800,
        format: 'webp',
        quality: 80
      })
      
      return {
        status: 'success',
        previewUrl,
        screenshot,
        buildTime: 200, // í•« ë¦¬ë¡œë“œëŠ” ë§¤ìš° ë¹ ë¦„
        fileSize: this.calculateFileSize(styleInjections),
        strategy: 'hot-reload'
      }
      
    } finally {
      this.previewPool.release(instance)
    }
  }
  
  private async generateFullBuildPreview(
    option: CustomizationOption,
    baseProject: ProjectState,
    analysis: ChangeAnalysis
  ): Promise<PreviewResult> {
    
    const buildStartTime = performance.now()
    
    // 1. ì„ì‹œ ë¹Œë“œ ë””ë ‰í† ë¦¬ ìƒì„±
    const tempDir = await this.createTempDirectory(`preview-${option.id}`)
    
    try {
      // 2. í”„ë¡œì íŠ¸ íŒŒì¼ ë³µì‚¬
      await this.copyProjectFiles(baseProject, tempDir)
      
      // 3. ë³€ê²½ì‚¬í•­ ì ìš©
      await this.applyChangesToProject(option.changes, tempDir)
      
      // 4. ë¹Œë“œ ì‹¤í–‰
      const buildResult = await this.buildManager.buildProject(tempDir, {
        mode: 'preview',
        optimization: false,
        sourcemap: false
      })
      
      if (!buildResult.success) {
        throw new Error(`Build failed: ${buildResult.errors.join(', ')}`)
      }
      
      // 5. í”„ë¦¬ë·° ì„œë²„ì— ë°°í¬
      const previewUrl = await this.deployPreview(buildResult.outputPath, option.id)
      
      // 6. ìŠ¤í¬ë¦°ìƒ· ìƒì„±
      const screenshot = await this.screenshotService.captureFullPage(previewUrl)
      
      return {
        status: 'success',
        previewUrl,
        screenshot,
        buildTime: performance.now() - buildStartTime,
        fileSize: await this.calculateBuildSize(buildResult.outputPath),
        strategy: 'full-build'
      }
      
    } finally {
      // ì„ì‹œ ë””ë ‰í† ë¦¬ ì •ë¦¬
      await this.cleanupTempDirectory(tempDir)
    }
  }
}

// 2. ìŠ¤í¬ë¦°ìƒ· ì„œë¹„ìŠ¤
class ScreenshotService {
  private browser: Browser | null = null
  
  async initialize(): Promise<void> {
    this.browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    })
  }
  
  async captureViewport(
    url: string,
    options: ScreenshotOptions = {}
  ): Promise<string> {
    
    if (!this.browser) {
      await this.initialize()
    }
    
    const page = await this.browser!.newPage()
    
    try {
      // ë·°í¬íŠ¸ ì„¤ì •
      await page.setViewport({
        width: options.width || 1200,
        height: options.height || 800,
        deviceScaleFactor: options.deviceScale || 1
      })
      
      // í˜ì´ì§€ ë¡œë“œ
      await page.goto(url, { waitUntil: 'networkidle0', timeout: 10000 })
      
      // ìŠ¤í¬ë¦°ìƒ· ì´¬ì˜
      const screenshot = await page.screenshot({
        type: options.format || 'png',
        quality: options.quality || 90,
        clip: {
          x: 0,
          y: 0,
          width: options.width || 1200,
          height: options.height || 800
        }
      })
      
      // ì´ë¯¸ì§€ ì—…ë¡œë“œ ë° URL ë°˜í™˜
      return await this.uploadScreenshot(screenshot, options.format || 'png')
      
    } finally {
      await page.close()
    }
  }
  
  async captureMultipleDevices(url: string): Promise<DeviceScreenshots> {
    const devices = [
      { name: 'desktop', width: 1200, height: 800 },
      { name: 'tablet', width: 768, height: 1024 },
      { name: 'mobile', width: 375, height: 667 }
    ]
    
    const screenshots: DeviceScreenshots = {}
    
    for (const device of devices) {
      screenshots[device.name] = await this.captureViewport(url, {
        width: device.width,
        height: device.height,
        format: 'webp',
        quality: 80
      })
    }
    
    return screenshots
  }
}
```

#### âœ… Phase 4 ì™„ë£Œ ê¸°ì¤€
- [ ] ë¹„êµ UI 3ê°€ì§€ ë·° ëª¨ë“œ ëª¨ë‘ ë™ì‘
- [ ] ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì‹œìŠ¤í…œ ì™„ì„±
- [ ] ìºì‹±ì„ í†µí•œ ì„±ëŠ¥ ìµœì í™” í™•ì¸
- [ ] ì „ì²´í™”ë©´ ë¯¸ë¦¬ë³´ê¸° ë° ë‹¤ì¤‘ ë””ë°”ì´ìŠ¤ ì§€ì›
- [ ] í‚¤ë³´ë“œ ë‚´ë¹„ê²Œì´ì…˜ ë“± ì ‘ê·¼ì„± ê¸°ëŠ¥ ì™„ì„±

---

## ğŸš€ Phase 5: ì„±ëŠ¥ ìµœì í™” ë° ë°°í¬ ì¤€ë¹„ (1ì£¼)

### Day 53-56: ì„±ëŠ¥ ìµœì í™”

#### ğŸ¯ ëª©í‘œ
ì „ì²´ ì‹œìŠ¤í…œì˜ ì„±ëŠ¥ì„ ìµœì í™”í•˜ê³  í”„ë¡œë•ì…˜ í™˜ê²½ì— ë°°í¬í•  ì¤€ë¹„ ì™„ì„±

#### ğŸ“‹ ì£¼ìš” ì‘ì—…

##### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”
```typescript
// 1. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric[]> = new Map()
  
  async measureOperation<T>(
    operationName: string,
    operation: () => Promise<T>,
    context?: Record<string, any>
  ): Promise<T> {
    
    const startTime = performance.now()
    const startMemory = process.memoryUsage()
    
    try {
      const result = await operation()
      
      this.recordMetric({
        name: operationName,
        duration: performance.now() - startTime,
        memoryDelta: this.calculateMemoryDelta(startMemory),
        status: 'success',
        context,
        timestamp: Date.now()
      })
      
      return result
      
    } catch (error) {
      this.recordMetric({
        name: operationName,
        duration: performance.now() - startTime,
        memoryDelta: this.calculateMemoryDelta(startMemory),
        status: 'error',
        error: error.message,
        context,
        timestamp: Date.now()
      })
      
      throw error
    }
  }
  
  generatePerformanceReport(): PerformanceReport {
    const report: PerformanceReport = {
      summary: {
        totalOperations: 0,
        averageResponseTime: 0,
        errorRate: 0,
        memoryUsage: process.memoryUsage()
      },
      breakdown: {},
      recommendations: []
    }
    
    // ë©”íŠ¸ë¦­ ë¶„ì„ ë° ë¦¬í¬íŠ¸ ìƒì„±
    for (const [operationName, metrics] of this.metrics.entries()) {
      const analysis = this.analyzeMetrics(metrics)
      report.breakdown[operationName] = analysis
      
      // ì„±ëŠ¥ ì„ê³„ê°’ í™•ì¸ ë° ê¶Œì¥ì‚¬í•­ ìƒì„±
      if (analysis.averageDuration > this.getThreshold(operationName)) {
        report.recommendations.push({
          operation: operationName,
          issue: 'slow_performance',
          recommendation: this.generateOptimizationRecommendation(operationName, analysis)
        })
      }
    }
    
    return report
  }
}

// 2. ìºì‹± ìµœì í™”
class OptimizedCacheManager {
  private memoryCache: LRUCache<string, any>
  private diskCache: DiskCache
  private compressionCache: CompressionCache
  
  constructor() {
    this.memoryCache = new LRUCache({ max: 1000, ttl: 1000 * 60 * 10 }) // 10ë¶„
    this.diskCache = new DiskCache('./cache')
    this.compressionCache = new CompressionCache()
  }
  
  async get<T>(key: string, options?: CacheOptions): Promise<T | null> {
    // 1. ë©”ëª¨ë¦¬ ìºì‹œ (ê°€ì¥ ë¹ ë¦„)
    let result = this.memoryCache.get(key)
    if (result !== undefined) {
      return result as T
    }
    
    // 2. ì••ì¶• ìºì‹œ (ì¤‘ê°„ ì†ë„, ë©”ëª¨ë¦¬ íš¨ìœ¨ì )
    if (options?.allowCompression) {
      result = await this.compressionCache.get(key)
      if (result !== null) {
        this.memoryCache.set(key, result)
        return result as T
      }
    }
    
    // 3. ë””ìŠ¤í¬ ìºì‹œ (ëŠë¦¬ì§€ë§Œ ì§€ì†ì )
    if (options?.allowDisk) {
      result = await this.diskCache.get(key)
      if (result !== null) {
        this.memoryCache.set(key, result)
        if (options?.allowCompression) {
          await this.compressionCache.set(key, result)
        }
        return result as T
      }
    }
    
    return null
  }
  
  async set<T>(key: string, value: T, options?: CacheOptions): Promise<void> {
    // ëª¨ë“  ë ˆë²¨ì— ë³‘ë ¬ë¡œ ì €ì¥
    const promises: Promise<any>[] = []
    
    // ë©”ëª¨ë¦¬ ìºì‹œ
    this.memoryCache.set(key, value)
    
    // ì••ì¶• ìºì‹œ (í° ë°ì´í„°ì˜ ê²½ìš°)
    if (options?.allowCompression && this.shouldCompress(value)) {
      promises.push(this.compressionCache.set(key, value))
    }
    
    // ë””ìŠ¤í¬ ìºì‹œ (ì¤‘ìš”í•œ ë°ì´í„°ì˜ ê²½ìš°)
    if (options?.allowDisk && options?.important) {
      promises.push(this.diskCache.set(key, value))
    }
    
    await Promise.allSettled(promises)
  }
}
```

##### Day 57-59: ìµœì¢… í…ŒìŠ¤íŠ¸ ë° ë°°í¬ ì¤€ë¹„
```typescript
// 3. í†µí•© í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸
class IntegrationTestSuite {
  async runFullTestSuite(): Promise<TestResults> {
    const results: TestResults = {
      passed: 0,
      failed: 0,
      tests: []
    }
    
    const testCases = [
      // ê¸°ë³¸ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
      () => this.testBasicMessageRouting(),
      () => this.testTemplateRecommendation(),
      () => this.testCustomizationGeneration(),
      () => this.testPreviewGeneration(),
      
      // ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
      () => this.testPerformanceThresholds(),
      () => this.testCacheEfficiency(),
      () => this.testMemoryUsage(),
      
      // ì•ˆì •ì„± í…ŒìŠ¤íŠ¸
      () => this.testErrorHandling(),
      () => this.testRollbackMechanism(),
      () => this.testFeatureFlagToggling(),
      
      // í˜¸í™˜ì„± í…ŒìŠ¤íŠ¸
      () => this.testBackwardCompatibility(),
      () => this.testLegacyFeatures()
    ]
    
    for (const testCase of testCases) {
      try {
        const testResult = await testCase()
        results.tests.push(testResult)
        if (testResult.passed) {
          results.passed++
        } else {
          results.failed++
        }
      } catch (error) {
        results.tests.push({
          name: testCase.name,
          passed: false,
          error: error.message
        })
        results.failed++
      }
    }
    
    return results
  }
  
  private async testBasicMessageRouting(): Promise<TestResult> {
    // AI ì›Œí¬í”Œë¡œìš° ë©”ì‹œì§€ ë¼ìš°íŒ… í…ŒìŠ¤íŠ¸
    const message: AIWorkflowMessage = {
      type: 'template:search',
      workflowType: 'template',
      sessionId: 'test-session',
      query: 'ë¸”ë¡œê·¸ ì‚¬ì´íŠ¸'
    }
    
    const result = await this.messageBridge.processMessage(message)
    
    return {
      name: 'Basic Message Routing',
      passed: result.type === 'template:search:result' && result.data.results.length > 0,
      duration: result.processingTime,
      details: result
    }
  }
  
  private async testPerformanceThresholds(): Promise<TestResult> {
    const thresholds = {
      templateRecommendation: 2000, // 2ì´ˆ
      customizationGeneration: 5000, // 5ì´ˆ
      previewGeneration: 10000, // 10ì´ˆ
      messageRouting: 100 // 100ms
    }
    
    const performanceResults = await this.performanceMonitor.runBenchmarks()
    
    const violations = []
    for (const [operation, threshold] of Object.entries(thresholds)) {
      const actual = performanceResults[operation]?.averageDuration || 0
      if (actual > threshold) {
        violations.push(`${operation}: ${actual}ms > ${threshold}ms`)
      }
    }
    
    return {
      name: 'Performance Thresholds',
      passed: violations.length === 0,
      details: { violations, results: performanceResults }
    }
  }
}

// 4. ë°°í¬ ì¤€ë¹„ ì²´í¬ë¦¬ìŠ¤íŠ¸
class DeploymentReadinessChecker {
  async checkReadiness(): Promise<ReadinessReport> {
    const checks = [
      () => this.checkDependencies(),
      () => this.checkConfiguration(),
      () => this.checkSecurity(),
      () => this.checkPerformance(),
      () => this.checkMonitoring(),
      () => this.checkBackup(),
      () => this.checkRollback()
    ]
    
    const results = await Promise.all(checks.map(check => check()))
    
    const passed = results.filter(r => r.passed).length
    const failed = results.filter(r => !r.passed).length
    
    return {
      ready: failed === 0,
      score: (passed / results.length) * 100,
      checks: results,
      recommendations: this.generateDeploymentRecommendations(results)
    }
  }
  
  private async checkSecurity(): Promise<ReadinessCheck> {
    const issues = []
    
    // API í‚¤ ë³´ì•ˆ í™•ì¸
    if (process.env.NODE_ENV === 'production') {
      if (!process.env.LLM_API_KEY || process.env.LLM_API_KEY.includes('test')) {
        issues.push('Production LLM API key not configured')
      }
    }
    
    // ì…ë ¥ ê²€ì¦ í™•ì¸
    const inputValidationTests = await this.testInputValidation()
    if (inputValidationTests.failed > 0) {
      issues.push(`Input validation failed: ${inputValidationTests.failed} tests`)
    }
    
    // CORS ì„¤ì • í™•ì¸
    const corsConfig = this.checkCorsConfiguration()
    if (!corsConfig.secure) {
      issues.push('CORS configuration is not secure for production')
    }
    
    return {
      name: 'Security',
      passed: issues.length === 0,
      issues,
      recommendations: issues.length > 0 ? ['Review security configuration'] : []
    }
  }
}
```

#### âœ… Phase 5 ì™„ë£Œ ê¸°ì¤€
- [ ] ëª¨ë“  ì„±ëŠ¥ ì„ê³„ê°’ ë§Œì¡± (í…œí”Œë¦¿ ì¶”ì²œ < 2ì´ˆ, ì»¤ìŠ¤í„°ë§ˆì´ì§• < 5ì´ˆ)
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ 95% ì´ìƒ í†µê³¼
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™” (< 512MB)
- [ ] ìºì‹œ íˆíŠ¸ìœ¨ 60% ì´ìƒ
- [ ] ë°°í¬ ì¤€ë¹„ë„ ì²´í¬ 100% í†µê³¼

---

## ğŸ“Š ìµœì¢… ê²€ì¦ ë° ì„±ê³µ ì§€í‘œ

### ğŸ¯ Phaseë³„ ì„±ê³µ ì§€í‘œ ë‹¬ì„± í™•ì¸

| Phase | ëª©í‘œ ì§€í‘œ | ë‹¬ì„± ê¸°ì¤€ | ê²€ì¦ ë°©ë²• |
|-------|-----------|-----------|-----------|
| Phase 1 | MessageBridge í™•ì¥ | ê¸°ì¡´ ê¸°ëŠ¥ 100% í˜¸í™˜ | ê¸°ì¡´ í…ŒìŠ¤íŠ¸ í†µê³¼ |
| Phase 2 | í…œí”Œë¦¿ ì¶”ì²œ ì •í™•ë„ | 80% ì´ìƒ | ì‚¬ìš©ì ë§Œì¡±ë„ ì¡°ì‚¬ |
| Phase 3 | ì»¤ìŠ¤í„°ë§ˆì´ì§• ì„±ê³µë¥  | 95% ì´ìƒ | ì œì•½ì¡°ê±´ ìœ„ë°˜ < 5% |
| Phase 4 | ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì†ë„ | í‰ê·  10ì´ˆ ì´ë‚´ | ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ |
| Phase 5 | ì „ì²´ ì‹œìŠ¤í…œ ì•ˆì •ì„± | ì—ëŸ¬ìœ¨ < 1% | í†µí•© í…ŒìŠ¤íŠ¸ |

### ğŸ† ìµœì¢… ì™„ì„± ê¸°ì¤€

#### âœ… ê¸°ëŠ¥ì  ì™„ì„±ë„
- [ ] ì‚¬ìš©ì ì…ë ¥ â†’ AI ë¶„ì„ â†’ í…œí”Œë¦¿ ì¶”ì²œ ì „ì²´ í”Œë¡œìš° ë™ì‘
- [ ] 3ê°€ì§€ ê°•ë„ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜µì…˜ ìƒì„± ë° ì ìš©
- [ ] ì‹¤ì‹œê°„ ë¹„êµ UI ë° ë¯¸ë¦¬ë³´ê¸° ì‹œìŠ¤í…œ ì™„ì„±
- [ ] ì œì•½ì¡°ê±´ ê²€ì¦ ë° í•´ê²°ë°©ì•ˆ ì œì‹œ ì‹œìŠ¤í…œ ë™ì‘

#### âœ… ê¸°ìˆ ì  ì™„ì„±ë„
- [ ] ê¸°ì¡´ Phase 1-5 ê¸°ëŠ¥ê³¼ 100% í˜¸í™˜
- [ ] Feature Flagë¥¼ í†µí•œ ì•ˆì „í•œ ë°°í¬/ë¡¤ë°± ê°€ëŠ¥
- [ ] ì„±ëŠ¥ ì„ê³„ê°’ ëª¨ë‘ ë§Œì¡±
- [ ] ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ëª¨ë‘ ì¶©ì¡±

#### âœ… ì‚¬ìš©ì ê²½í—˜ ì™„ì„±ë„
- [ ] ì§ê´€ì ì¸ ëŒ€í™”ì‹ ì¸í„°í˜ì´ìŠ¤
- [ ] ê°œì¸í™”ëœ ì¶”ì²œ ì‹œìŠ¤í…œ ë™ì‘
- [ ] ì‹¤ì‹œê°„ í”¼ë“œë°± ë° ë¯¸ë¦¬ë³´ê¸°
- [ ] ì ‘ê·¼ì„± ê¸°ëŠ¥ ì™„ë¹„

ì´ êµ¬í˜„ ê³„íšì„ í†µí•´ WindWalkerëŠ” **ì‹œì¥ ìµœê³  ìˆ˜ì¤€ì˜ AI ëŒ€í™”ì‹ ì›¹ì‚¬ì´íŠ¸ ë¹Œë”**ë¡œ ì™„ì„±ë  ê²ƒì…ë‹ˆë‹¤.